Define Circuit-level Modules
============================

To support FPGA SPICE, Verilog and Bitstream Generator, physical modules containing gate-level and transistor-level features are required for FPGA primitive blocks.
The physical modules are defined in XML syntax, similar to the original VPR FPGA architecture description language.

For each module that appears in the FPGA architecture, a circuit model should be defined. In the definition of a circuit model, user can specify if the SPICE netlist of the module is either auto-generated or user-defined. 

Define circuit_models
--------------------- 

.. code-block:: xml

  <module_circuit_models>
    <circuit_model type="string" name="string" prefix="string" is_default="int" [spice|verilog]_netlist="string" dump_structural_verilog="string">
      <transistor-level circuit design features>
    </circuit_model>
  </module_circuit_models>

* **module_circuit_models**: the father node for all the spice models. All the spice models should be defined under this XML node. 

	* **circuit_model**: the child node defining transistor-level modeling parameters. 

		* **type**: can be [ inv_buf | pass_gate | mux | wire | chan_wire | sram | lut | ff | sff | hard_logic | iopad ]. Specify the type of this circuit model. The provided types cover all the modules in FPGAs. For the circuit models in the type of mux/wire/chan_wire/lut, FPGA-SPICE can auto-generate SPICE netlists. For the rest, FPGA-SPICE requires a user-defined SPICE netlist.

		* **name**: define the name of this circuit model. The name should be unique and will be used in create the sub-circuit of the circuit model in SPICE netlists. Note that for a customized SPICE netlist, the name defined here should be the name of the top-level sub-circuit in the customized SPICE netlist. FPGA-SPICE will check if the given name is conflicted with any reserved words.

		* **prefix**: specify the name of the circuit_model to shown in the auto-generated SPICE netlists. The prefix can be the same as the name defined above. And again, the prefix should be unique. 

		* **is_default**: can be [1|0], corresponding to [true|false] respectively. Specify this circuit model is the default one for some modules, such as multiplexers. If a module is not linked to any spice model by users, FPGA-SPICE will find the default spice model defined in the same type and link.  For a spice model type, only one spice model can be set as default.

		* **spice_netlist**: specify the path and file name of a customized SPICE netlist. For some modules such as SRAMs, FFs, inpad and outpads, FPGA-SPICE does not support auto-generation of the transistor-level sub-circuits because their circuit design are highly dependent on the technology nodes. These circuit designs should be specified by users. For the other modules that can be auto-generated by FPGA-SPICE, user can also define a custom netlist. Multiplexers can not be user-defined.

		* **verilog_netlist**: specify the path and file name of a customized Verilog netlist. For some modules such as SRAMs, FFs, inpad and outpads, FPGA-SPICE does not support auto-generation of the transistor-level sub-circuits because their circuit design are highly dependent on the technology nodes. These circuit designs should be specified by users. For the other modules that can be auto-generated by FPGA-SPICE, user can also define a custom netlist. Multiplexers can not be user-defined.

		* **dump_structural_verilog**: when the value of this keyword is set to be true, Verilog generator will output gate-level netlists of this module, instead of behavior-level. Gate-level netlists bring more opportunities in layout-level optimization while behavior-level is more suitable for high-speed formal verification and easier in debugging with HDL simulators.

.. note:: If netlist is not specified, FPGA-SPICE auto-generates the SPICE netlists for multiplexers, wires and LUTs.

.. note:: The user-defined netlists, such as LUTs, the decoding methodology should comply with the auto-generated LUTs (See Section 4.5)

.. note:: Under the XML node circuit_model, the features of transistor-level designs can be defined. In the following table, we show the common features supported for all the modules.  Then, we will introduce unique features supported only for some spice models types.


Transistor level
----------------

.. code-block:: xml

  <circuit_model type="string" name="string" prefix="string" is_default="int" netlist="string" dump_structural_verilog="string">
    <design_technology type="string"/>
    <input_buffer exist="string" circuit_model_name="string"/>
    <output_buffer exist="string" circuit_model_name="string"/>
    <pass_gate_logic type="string" circuit_model_name="string"/>
    <port type="string" prefix="string" size="int" default_val="int" circuit_model_name="string" mode_select="boolean" is_global="boolean" is_set="boolean" is_reset="boolean" is_config_enable="boolean"/>
  </circuit_model>

* design_technology :

	* type: [cmos|rram]. Specify the type of design technology of the circuit_model. 

.. note:: Currently, the RRAM-based designs are only supported for multiplexers.

* input_buffer and output_buffer: 
	
	* exist: [on|off]. Define the existence of the input_buffer or output_buffer. Note that the existence is valid for all the inputs and outputs. Note that if users want only part of the inputs (or outputs) to be buffered, this is not supported here. A solution can be building a user-defined SPICE netlist.

	* circuit_model_name: Specify the name of circuit model which is used to implement input/output buffer, the type of specified circuit model should be inv_buf.

* pass_gate_logic: defined the parameters in pass-gates, which are used in building multiplexers and LUTs.

	* circuit_model_name: Specify the name of circuit model which is used to implement transmission gate, the type of specified spice model should be pass_gate.

* port: define the port list of a circuit model. 

	* type: can be [input|output|sram|clock]. For programmable modules, such as multiplexers and LUTs, SRAM ports should be defined. For registers, such as FFs and memory banks, clock ports should be defined.

	* prefix: the name of the port. Each port will be shown as <prefix>[i], 0≤i<size in SPICE netlists.

	* size: bandwidth of the port. 

	* default_val:  default logic value of a port, which is used as initial logic value of this port in testbench generation. Can be either 0 or 1. We assume each pin of this port has the same default value.

	* circuit_model_name: only valid when the type of port is sram. Specify the name of circuit model which is connected to this port.

	* mode_select: can be either true or false. Specify if this port controls the mode switching in a configurable logic block. Only valid when the type of this port is sram. (A configurable logic block can operate in different modes, which is controlled by SRAM bits.) 

	* is_global: can be either true or false. Specify if this port is a global port, which will be routed globally. Note that when multiple global ports are defined with the same name, these global ports will be short-wired together.

	* is_set: can be either true or false. Specify if this port controls a set signal. Only valid when is_global is true. All the set ports are connected to a global set voltage stimuli in testbenches.

	* is_reset: can be either true or false. Specify if this port controls a reset signal. Only valid when is_global is true. All the reset ports are connected to a global reset voltage stimuli in testbenches.

	* is_config_enable: can be either true or false. Only valid when is_global is true. Specify if this port controls a configuration-enable signal. This port is only enabled during FPGA configuration, and always disabled during FPGA operation. All the config_enable ports are connected to a global configuration-enable voltage stimuli in testbenches.

Circuit model examples
======================
The nexts subsections are dedicated to detailed examples of each circuit model type. Through these examples any configuration of any type will be illustrated.

Inverters and Buffers
---------------------

.. code-block:: xml

  <circuit_model type="inv_buf" name="string" prefix="string" netlist="string" is_default="int"/>
    <design_technology type="cmos" topology="string" size="int" tapered="off"/>
    <port type="input" prefix="string" size="int"/>
    <port type="output" prefix="string" size="int"/>
  </circuit_model>

.. note:: customized SPICE netlists are not currently supported for inverters and buffers. 

* design_technology:

	* **topology:** [inverter|buffer]. Specify the type of this component, can be either an inverter or a buffer.

	* **size:** Specify the driving strength of inverter/buffer. For a buffer, the size is the driving strength of the inverter at the second level. We consider a two-level structure for a buffer here. The support for multi-level structure of a buffer will be introduced in the tapered options.

	* **tapered:** [on|off]. Define if the buffer is a tapered (multi-level) buffer. *If "on" the following parameter are required.* 

		* **tap_drive_level:** Define the number of levels of a tapered buffer. This parameter is valid only when tapered is turned on.

		* **f_per_stage:** Define the ratio of driving strength between the levels of a tapered driver. This parameter is valid only when tapered is turned on. Default value is 4.

**Inverter x1 example**

:numref:`fig_inv1` is the inverter symbol depicted in this example.

.. _fig_inv1:

.. figure:: ./figures/Inverter_1.png
   :scale: 100%
   :alt: classical inverter x1 symbol

   Classical inverter x1 symbol

The XML code to describe this inverter is:

.. code-block:: xml

  <circuit_model type="inv_buf" name="inv1x" prefix="inv1x">
    <design_technology type="cmos" topology="inverter" size="1"/>
    <port_type="input" prefix="in" size="1"/>
    <port_type="output" prefix="out" size="1"/>
  </circuit_model>

This example shows:
	* The topology chose as inverter
	* Size of 1 for the output strength
	* The tapered parameter is not declared and is off by default


**Buffer x2 example**

:numref:`fig_buff` is the buffer symbol depicted in this example.

.. _fig_buff:

.. figure:: ./figures/Buffer.png
   :scale: 100%
   :alt: buffer symbol composed by 2 inverter, its output strength equal 2

The XML code to describe this buffer is:

.. code-block:: xml

  <circuit_model type="inv_buf" name="buf2" prefix="buf2">
    <design_technology type="cmos" topology="buffer" size="2"/>
    <port_type="input" prefix="in" size="1"/>
    <port_type="output" prefix="out" size="1"/>
  </circuit_model>

This example shows:
	* The topology chose as buffer
	* Size of 2 for the output strength
	* The tapered parameter is not declared and is off by default


**Tapered inverter x16 example**

:numref:`fig_invtap4` is the tapered inverter symbol depicted this example.

.. _fig_invtap4:

.. figure:: ./figures/Tapered_inverter.png
   :scale: 100%
   :alt: tapered inverter composed by 3 inverter for an output strength = 16

The XML code to describe this inverter is:

.. code-block:: xml

  <circuit_model type="inv_buf" name="tapdrive4" prefix="tapdrive4"> 
    <design_technology type="cmos" topology=”inverter" size="1" tapered="on" tap_drive_level="3" f_per_stage="4"/> 
    <port_type="input" prefix="in" size="1"/> 
    <port_type="output" prefix="out" size="1"/>
  </circuit_model> 


This example shows:
	* The topology chose as inverter
	* Size of 1 for the first stage output strength
	* The tapered parameter is on. Then the required sub parameters are declared
		* The number of stage is set to 3 by tap_drive_level
		* f_per_stage is set to 4. Then 2nd stage output strength is 4* the 1st stage output strength (so 4*1 = 4) and the 3rd stage output strength is 4* the 2nd stage output strength (so 4*4 =  


Pass-gate Logic
---------------

.. code-block:: xml 

  <circuit_model type="pass_gate" name="string" prefix="string" netlist="string" is_default="int"/>
    <design_technology type="cmos" topology="string" nmos_size="int" pmos_size="int" tapered="off"/>
    <input_buffer exist="string" circuit_model_name="string" />
    <output_buffer exist="string" circuit_model_name="string" />
    <port type="input" prefix="string" size="int"/>
    <port type="output" prefix="string" size="int"/>
  </circuit_model>

.. note:: customized SPICE netlists are not currently supported for pass-gate logics. 

* design_technology:

	* **topology:** [transmission_gate|pass_transistor]. The transmission gate consists of a NMOS transistor and a PMOS transistor. The pass transistor consists of a NMOS transistor.

	* **nmos_size:** the size of NMOS transistor in a transmission gate or pass_transistor, expressed in terms of the min_width defined in XML node <transistors>.

	* **pmos_size:** the size of PMOS transistor in a transmission gate, expressed in terms of the min_width defined in XML node <transistors>.

SRAMs
-----

.. code-block:: xml 

  <circuit_model type="sram" name="string" prefix="string" netlist="string"/>
    <design_technology type="cmos"/>
    <input_buffer exist="string" circuit_model_name="string"/>
    <output_buffer exist="string" circuit_model_name="string"/>
    <port type="input" prefix="string" size="int"/>
    <port type="output" prefix="string" size="int"/>
  </circuit_model>

.. note::  The circuit designs of SRAMs are highly dependent on the technology node and well optimized by engineers. Therefore, FPGA-SPICE requires users to provide their customized SRAM SPICE netlists. A sample SPICE netlist of SRAM can be found in the directory SpiceNetlists in the released package. FPGA-SPICE assumes that all the LUTs and MUXes employ the SRAM circuit design. Therefore, currently only one SRAM type is allowed to be defined.

.. note:: The information of input and output buffer should be clearly specified according to the customized SPICE netlist! The existence of input/output buffers will influence the decision in creating testbenches, which may leads to larger errors in power analysis.

.. note:: The support SRAM modules should have a BL and a WL when the memory-bank-style configuration circuit is declared. Note that the WL should be the write/read enable signal, while BL is the data input.


Multiplexers
------------

.. code-block:: xml 

  <circuit_model type="mux" name="string" prefix="string" is_default="int"/>
    <design_technology type="string" structure="string" num_level="int" ron="float" roff="float" prog_transistor_size="float"/>
    <input_buffer exist="string" circuit_model_name="string"/>
    <output_buffer exist="string" circuit_model_name="string"/>
    <pass_gate_logic type="string" circuit_model_name="string"/>
    <port type="input" prefix="string" size="int"/>
    <port type="output" prefix="string" size="int"/>
    <port type="sram" prefix="string" size="int"/>
  </circuit_model>

.. note:: customized SPICE netlists are not currently supported for multiplexers. 

* design_technology: 

	* structure: can be [tree|multi-level|one-level]. The structure options are valid for SRAM-based multiplexers. For RRAM-based multiplexers, currently we only support the circuit design in [5].

	* num_level: specify the number of levels when multi-level structure is selected.

	* ron: valid only when the type of design technology is rram. Specify the on-resistance of the RRAM device used in the RRAM-based multiplexer. 

	* roff: valid only when the type of design technology is rram. Specify the off-resistance of the RRAM device used in the RRAM-based multiplexer. 

	* prog_transistor_size: valid only when the type of design technology is rram. Specify the size of programming transistors used in the RRAM-based multiplexer, we use only n-type transistor and the size should be expressed in terms of the min_width defined in XML node <transistors>.

* port: for a multiplexer, the three types of ports, input, output and sram should be defined. 

:numref:`fig_mux` illustrates an example of multiplexer modelling, which consists of input/output buffers and a transmission-gate-based tree structure.

.. _fig_mux:

.. figure:: ./figures/mux.png
   :scale: 100%
   :alt: map to buried treasure

   An example of a tree-like multiplexer with transistor-level design parameters


Look-Up Tables
--------------

.. code-block:: xml 

  <circuit_model type="lut" name="string" prefix="string" is_default="int" netlist="string"/>
    <design_technology type="cmos"/>
    <lut_input_buffer exist="string" circuit_model_name="string"/>
    <input_buffer exist="string" circuit_model_name="string"/>
    <output_buffer exist="string" circuit_model_name="string"/>
    <pass_gate_logic type="string" circuit_model_name="string"/>
    <port type="input" prefix="string" size="int"/>
    <port type="output" prefix="string" size="int"/>
    <port type="sram" prefix="string" size="int"/>
  </circuit_model>

.. note:: The SPICE netlists of LUT can be auto-generated or customized. 
  The auto-generated LUTs are based on a tree-like multiplexer, whose gates of the transistors are used as the inputs of LUTs and the drains/sources of the transistors are used for configurable memories (SRAMs).
  The LUT provided in customized SPICE netlist should have the same decoding methodology as the traditional LUT. 

Additional design parameters for LUTs: 

* lut_input_buffer : Specify the buffer for the inputs of a LUT (gates of the internal multiplexer). 

Instructions of defining design parameters:

* input_buffer: Specify the buffer/inverter that connects the SRAM outputs to the inputs of multiplexer. 

* pass_gate_logic: Specify the pass-gates of the internal multiplexer, the same as the multiplexers.

* port: three types of ports (input, output and sram) should be defined. If the user provides an customized SPICE netlist, the bandwidth of ports should be defined to the same as the SPICE netlist.

:numref:`fig_lut` illustrates an example of LUT modeling, which consists of input/output buffers and a transmission-gate-based tree structure.

.. _fig_lut:

.. figure:: ./figures/lut.png
   :scale: 100%
   :alt: map to buried treasure

   An example of a LUT with transistor-level design parameters.

Flip-Flops
----------

.. code-block:: xml

  <circuit_model type="ff" name="string" prefix="string" netlist="string"/>
    <design_technology type="cmos"/>
    <input_buffer exist="string" circuit_model_name="string"/>
    <output_buffer exist="string" circuit_model_name="string"/>
    <port type="input" prefix="string" size="int"/>
    <port type="output" prefix="string" size="int"/>
    <port type="clock" prefix="string" size="int"/>
  </circuit_model>

.. note:: The circuit designs of flip-flops are highly dependent on the technology node and well optimized by engineers. Therefore, FPGA-SPICE requires users to provide their customized SRAM SPICE netlists. A sample SPICE netlist of FF can be found in the directory SpiceNetlists in the released package. 
  
  The information of input and output buffer should be clearly specified according to the customized SPICE netlist! The existence of input/output buffers will influence the decision in creating testbenches, which may leads to larger errors in power analysis.

  FPGA-SPICE currently support only one clock domain in the FPGA. Therefore there should be only one clock port to be defined and the size of the clock port should be 1.

Instructions of defining design parameters:

* port: three types of ports (input, output and clock) should be defined. If the user provides a customized SPICE netlist, the bandwidth of ports should be defined to the same as the SPICE netlist.

Hard Logics
-----------

.. code-block:: xml

  <circuit_model type="hardlogic" name="string" prefix="string" netlist="string"/>
    <design_technology type="cmos"/>
    <input_buffer exist="string" circuit_model_name="string"/>
    <output_buffer exist="string" circuit_model_name="string"/>
    <port type="input" prefix="string" size="int"/>
    <port type="output" prefix="string" size="int"/>
  </circuit_model>

.. note:: hard logics are defined for non-configurable resources in FPGA architectures, such as adders, multipliers and RAM blocks.  
  Their circuit designs are highly dependent on the technology node and well optimized by engineers. 
  As more functional units are included in FPGA architecture, it is impossible to auto-generate these functional units [3]. 
  Therefore, FPGA-SPICE requires users to provide their customized SPICE netlists. A sample SPICE netlist of a 1-bit adder can be found in the directory SpiceNetlists in the released package. 

  The information of input and output buffer should be clearly specified according to the customized SPICE netlist! The existence of input/output buffers will influence the decision in creating testbenches, which may leads to larger errors in power analysis.

Instructions of defining design parameters:

* port: two types of ports (input and output) should be defined. If the user provides a user-defined SPICE netlist, the bandwidth of ports should be defined to the same as the SPICE netlist. 

Routing Wire Segments
---------------------
FPGA-SPICE provides two types of SPICE models for the wire segments in FPGA architecture. One type is called wire, which targets the local wires inside the logic blocks. The wire has one input and one output, directly connecting the output of a driver and the input of the downsteam unit, respectively
The other type is called chan_wire, especially targeting the channel wires. The channel wires have one input and two outputs, one of which is connected to the inputs of Connection Boxes while the other is connected to the inputs of Switch Boxes. Two outputs are created because from the view of layout, the inputs of Connection Boxes are typically connected to the middle point of channel wires, which has less parasitic resistances and capacitances than connected to the ending point.

.. code-block:: xml

  <circuit_model type="string" name="string" prefix="string" netlist="string"/>
    <design_technology type="cmos"/>
    <input_buffer exist="string" circuit_model_name="string"/>
    <output_buffer exist="string" circuit_model_name="string"/>
    <port type="input" prefix="string" size="int"/>
    <port type="output" prefix="string" size="int"/>
    <wire_param model_type="string" res_val="float" cap_val="float" level="int"/>
  </circuit_model>

.. note:: FPGA-SPICE can auto-generate the SPICE model for wires while also allows users to provide their customized SPICE netlists. 

  The information of input and output buffer should be clearly specified according to the customized SPICE netlist! The existence of input/output buffers will influence the decision in creating testbenches, which may leads to larger errors in power analysis.

Instructions of defining design parameters:

* type: can be [wire|chan_wire]. The SPICE model wire targets the local wire inside the logic block while the chan_wire targets the channel wires in global routing.

* port: two types of ports (input and output) should be defined. If the user provides an customized SPICE netlist, the bandwidth of ports should be defined to the same as the SPICE netlist. 

* wire_param:

	* model_type: can be [pie|T], corresponding to the π-type and T-type RC wire models. 
	* res_val: specify the total resistance of the wire
	* cap_val: specify the total capacitance of the wire.
	* level: specify the number of levels of the RC wire model.

:numref:`fig_wire` depicts the modeling for a length-2 channel wire.

.. _fig_wire:

.. figure:: ./figures/wire.png
   :scale: 100%
   :alt: map to buried treasure

   An example of a length-2 channel wire modeling

I/O pads
--------

.. code-block:: xml

  <circuit_model type="iopads" name="string" prefix="string" netlist="string"/>
    <design_technology type="cmos"/>
    <input_buffer exist="string" circuit_model_name="string"/>
    <output_buffer exist="string" circuit_model_name="string"/>
    <port type="input" prefix="string" size="int"/>
    <port type="output" prefix="string" size="int"/>
    <port type="sram" prefix="string" size="int" mode_select="true|false" circuit_model_name="string" default_val="int"/>
  </circuit_model>

.. note::  The circuit designs of I/O pads are highly dependent on the technology node and well optimized by engineers. 
  Therefore, FPGA-SPICE requires users to provide their customized SPICE netlists. A sample SPICE netlist of an I/O pad can be found in the directory SpiceNetlists in the released package. 

  The information of input and output buffer should be clearly specified according to the customized SPICE netlist! The existence of input/output buffers will influence the decision in creating testbenches, which may leads to larger errors in power analysis.

Instructions of defining design parameters:

* port: two types of ports (input and output) should be defined. If the user provides a user-defined SPICE netlist, the bandwidth of ports should be defined to the same as the SPICE netlist. 



6)