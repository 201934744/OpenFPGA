.. _uvm_tutorial:

UVM Tutorial
------------

This tutorial will show an example how to 
  - Run the UVM testbench generated by the openfpga_flow
  - Modify the testbench to fit any type of configuration
  - Enable the testbench to be self-checking
  
.. note:: UVM testbench generation is supported with a frame-base configuration protocol FPGA.

.. note:: Content described here : https://github.com/LNIS-Projects/OpenFPGA/tree/samy_sva-1/openfpga_flow/uvm

Run the UVM testbench
~~~~~~~~~~~~~~~~~~~~~

.. code-block:: shell

  cd ${TASK_DIRECTORY}/latest/{ARCH_NAME}/{BENCHMARK_NAME}/MIN_ROUTE_CHAN_WIDTH
  vsim &

.. note:: ``${TASK_DIRECTORY}`` is the root directory of the task

          ``${ARCH_NAME}`` depends on which arch is specified in the task.conf file
	  
          ``${BENCHMARK_NAME}`` depends on which benchmark is specified in the task.conf file
	  
	  The following path will be referend as ``${WORK_DIR} in this tutorial

Now in Modelsim terminal :

.. code-block:: shell

  source ${TASK_DIRECTORY}/latest/{ARCH_NAME}/{BENCHMARK_NAME}/MIN_ROUTE_CHAN_WIDTH/uvm/scripts/openfpga_variables.tcl
  top_create_new_project
  simulate_genmode
  
This sets the modelsim project and launch simulation with the current benchmark test_case.

Modify the testbench to fit other type of configuration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Current testbench support frame based configuration.
You can support other configuration by modifying :

.. code-block:: shell

   gedit ${WORK_DIR}/uvm/tb/bs_agent/bs_if.sv
   ${WORK_DIR}/uvm/tb/bs_agent/bs_seq_item.sv
   ${WORK_DIR}/uvm/tb/bs_agent/seq_lib/bs_base_seq.sv
   ${WORK_DIR}/uvm/tb/bs_agent/bs_driver.sv
   ${WORK_DIR}/uvm/tb/openfpga_tb/openfpga_tb.sv

You need to adapt configuration signal's names.
For example, you can switch from frame based configuration to configuration chain by converting :

.. code-block:: systemverilog

   logic [0:0]  data_in; // Configuration signal
   logic [0:ADDR_WIDTH] address; // Configuration signal
   
To :

.. code-block:: systemverilog

   logic [0:0] ccff_head; // Configuration signal
   logic [0:0] sc_head; // Configuration signal
   
You need to modify signals name & width in the 5 mentionned above file.

Enable the testbench to be self-checking
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We need a systemverilog package that mimic the behavior of your benchmark.
An example can be found for the andgate benchmark here :

.. code-block:: shell

   gedit ${WORK_DIR}/uvm/tb/and.sv

.. note:: You can run "simulate" in modelsim instead of "simulate_genmode" after creating a project to run the self-checking testbench for an andgate benchmark

Modify modelsim script located here :

.. code-block:: shell

   gedit ${WORK_DIR}/uvm/scripts/openfpga_variables.tcl

Right after and_package declaration :

.. code-block:: tcl

   set vars(ref_model)			"../and.sv"

Add the following line:

.. code-block:: tcl

   set vars(ref_model2)			"../{yourbenchmark}.sv"

.. note::``{yourbenchmark}``can be any name.
.. note:: The path has to be adapted, or you need to bring your package to this location

Modify the test_case file :

.. code-block:: shell

   gedit ${WORK_DIR}/uvm/tb/openfpga_test/benchmark_gen_test.sv

.. code-block:: systemverilog

         uvm_config_db #(string) 	:: set (null, "uvm_test_top", "test_name", "benchmark");
 
Becomes :

.. code-block:: systemverilog

         uvm_config_db #(string) 	:: set (null, "uvm_test_top", "test_name", "{yourbenchmark}");
         
Finally in the reference model located here :
 
.. code-block:: shell
 
    gedit ${WORK_DIR}/uvm/tb/openfpga_env/reference_model
 
Add a new testcase in the run_phase task :
 
.. code-block:: systemverilog

    	"{yourbenchmark}":
	begin
                new_tr.gfpga_pad_GPIO_IN_drv[{output_index}] =
		{yourbenchmark}_pkg::{yourbenchmark}(new_tr.gfpga_pad_GPIO_IN_drv[{input_index}],
		new_tr.gfpga_pad_GPIO_IN_drv[{input_index2}]);
      	end
       
.. note::``{input & output index}``have to be tailored according to your benchmark package & fpga IO's configuration.
 
 
