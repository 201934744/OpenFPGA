# THis script creates top level wrapper for the FPGA Core
# THe GPIo Pin assignement can be provided with csv file or
# Link to google published sheet
import veriloggen as vgen
import pyverilog.utils.version
import sys
from pyverilog.vparser import ast
from pyverilog.vparser.parser import parse
import pandas as pd
import os
import re
import shutil
import argparse


SIDE_MAP = ["", "left", "right", "top", "bottom"]

PIN_MAP = [" ", "GPortIn", "GPIO", "SPY",
           "VDD", "VSS", "DVDD", "DVSS",
           "PVDDTIE", "GPortOut"]
PAD_SIZE = {"PVDD_08_08_NT_DR": 35,
            "PVSS_08_08_NT_DR": 35,
            "PDVDD_18_18_NT_DR": 35,
            "PDVSS_18_18_NT_DR": 35,
            "PDVDDTIE_18_18_NT_DR": 35,
            "PBIDIR_18_18_NT_DR": 30,
            "PINCNP_18_18_NT_DR": 25}

INITIAL_OFFSET = 55
EDGE_OFFSET = 75
TYPICAL_OFFSET = 50


def formatter(prog): return argparse.HelpFormatter(prog, max_help_position=60)


parser = argparse.ArgumentParser(formatter_class=formatter)

# Mandatory arguments
parser.add_argument('--core_netlist', type=str, default="fpga_top_temp.v")
parser.add_argument('--pinmap_file', type=str, default="./arch/pin_map.csv")
parser.add_argument('--out_file', type=str, default="fpga22_Hie_top.v")
args = parser.parse_args()


def main():
    PinMapdf = LoadData(args.pinmap_file)
    TranslatePinNames(PinMapdf)
    print(PinMapdf.head(50))
    PortList = ParseInputVerilog()
    # Remove all the modules definition
    top = CreateTopWrapper(PortList, PinMapdf)
    modules = [each for each in top.submodule]
    for eachM in modules:
        del top.submodule[eachM]
    top.to_verilog(args.out_file)
    fix_verilog_format()
    CreateFloorPlanInfo(PinMapdf)
    IoRingPadConstraints(PinMapdf)
    GenerateDesignUPF(PinMapdf)


def GenerateDesignUPF(PinMapdf):
    with open("power_intent.upf", "w") as fp:
        fp.write("## UPF Generate for the design\n\n")
        fp.write(
            "create_power_domain IO_RING_SUPPLY -elements {%s}\n" % " ".join(PinMapdf["Instance_Name"]))
        fp.write("\ncreate_power_domain SUPPLY_CORE -include_scope\n")
        fp.write("\n")
        fp.write("## ========== Create Connections ==========\n")
        fp.write("## ========== VDD 0.8V\n")
        fp.write("create_supply_port VDD -domain SUPPLY_CORE\n")
        fp.write("create_supply_net VDD -domain SUPPLY_CORE\n")
        fp.write("connect_supply_net VDD -ports VDD\n")
        fp.write("\n")
        fp.write("## ========== DVDD 1.8V\n")
        fp.write("create_supply_port DVDD -domain IO_RING_SUPPLY\n")
        fp.write("create_supply_net DVDD -domain IO_RING_SUPPLY\n")
        fp.write("connect_supply_net DVDD -ports DVDD\n")
        fp.write("\n")
        fp.write("## ========== VSS 0V\n")
        fp.write("create_supply_port VSS -domain SUPPLY_CORE\n")
        fp.write("create_supply_net VSS -domain SUPPLY_CORE\n")
        fp.write("connect_supply_net VSS -ports VSS\n")
        fp.write("\n")
        fp.write("## ========== VSS 0V\n")
        fp.write("create_supply_port DVSS -domain IO_RING_SUPPLY\n")
        fp.write("create_supply_net DVSS -domain IO_RING_SUPPLY\n")
        fp.write("connect_supply_net DVSS -ports DVSS\n")
        fp.write("\n")
        fp.write("set_domain_supply_net SUPPLY_CORE" +
                 " -primary_power_net VDD -primary_ground_net VSS\n")
        fp.write("set_domain_supply_net IO_RING_SUPPLY" +
                 " -primary_power_net DVDD -primary_ground_net DVSS\n")


def CreateFloorPlanInfo(PinMapdf):
    NumberOfIOs = PinMapdf["Number"].max()
    DIE_HEIGHT = (100 + 65)*2 + \
        (6*EDGE_OFFSET) + \
        ((NumberOfIOs-5)*TYPICAL_OFFSET)
    DIE_WIDTH = DIE_HEIGHT
    with open("proj_const.tcl", "w") as fp:
        fp.write("## Floorplan information generated by script\n")
        fp.write(f"set PADS_EACH_SIDE {NumberOfIOs}\n")
        fp.write(f"set DIE_HEIGHT {DIE_HEIGHT}\n")
        fp.write(f"set DIE_WIDTH {DIE_WIDTH}\n")


def IoRingPadConstraints(PinMapdf):
    NumberOfIOs = PinMapdf["Number"].max()

    PinMapdf['Pad_size'] = PinMapdf.apply(
        lambda row: PAD_SIZE[row.Cell], axis=1)
    PinMapdf['Pitch'] = PinMapdf.apply(
        lambda row: INITIAL_OFFSET if (row.Number == 1) else
        (EDGE_OFFSET if (row.Number <= 3) or (row.Number > (NumberOfIOs-2))
         else TYPICAL_OFFSET),
        axis=1)

    for eachSide in range(1, 5):
        dfslice = PinMapdf[PinMapdf['Side'] == eachSide][[
            "Number", "Instance_Name", "Pitch", "Pad_size"]]
        dfslice.sort_values(by=['Number'])
        dfslice['Pad_pitch'] = dfslice['Pitch'].cumsum()
        dfslice['Distance'] = dfslice.apply(
            lambda row: row.Pad_pitch-((row.Pad_size)*0.5), axis=1)
        dfslice.to_csv(f"gpio_{SIDE_MAP[eachSide]}.csv", index=False)
        print(dfslice.head(10))
    with open("csv_pads.map", "w") as fp:
        fp.write("Instance_Name, Pad Name\n")
        fp.write("Distance, Offset Value\n")


def fix_verilog_format():
    print("Running formatter")
    with open("tmp.v", "w") as fp:
        with open(args.out_file, "r") as fpr:
            for eachL in fpr.readlines():
                z = re.match("^.*\[(.*):(.*)].*$", eachL)
                if z:
                    fIndex = z.groups()[0]
                    eachL = eachL.replace(fIndex, str(eval(fIndex)))
                fp.write(eachL)
    os.remove(args.out_file)
    shutil.move("tmp.v", args.out_file)


def CreateTopWrapper(PortList, PinMap):
    m = vgen.Module('fpga_top')
    uut = vgen.Module("fpga_core")
    uutportMap = []

    # DVDD = m.Inout('DVDD_pad')
    # DVSS = m.Inout('DVSS_pad')
    for eachPin, prop in PortList.items():
        if ("gfpga" not in eachPin):
            prop["Port"] = eval(
                f"m.{prop['type']}('{eachPin}_pad',{prop['width']})")
        elif ("GPIO_Y" in eachPin):
            prop["Port"] = eval(
                f"m.{prop['type']}('gpio_pad',{prop['width']})")
        eval(f"uut.{prop['type']}('{eachPin}',{prop['width']})")
        prop["Wire"] = eval(f"m.Wire('{eachPin}',{prop['width']})")
        uutportMap.append((f'{eachPin}', prop["Wire"]))

    # DVDD_W = m.Wire('DVDD')
    # DVSS_W = m.Wire('DVSS')
    SNS = m.Wire('SNS')
    RTO = m.Wire('RTO')
    LOW = m.Wire('TIELOW', 100)
    HIGH = m.Wire('TIEHIGH', 100)
    UNCONN = m.Wire('UNCONN', 100)
    # DVDD.assign(DVDD_W)
    # DVSS.assign(DVSS_W)
    unconnIndex = 0
    tieHighIndex = 0
    tieLowIndex = 0

    m.Instance(uut, "fpga_core_uut", ports=tuple(uutportMap))
    PadInst = GPIO_PAD()

    SLbl = ["None", "H", "H", "V", "V"]
    GPIOModulesInstance = {
        "PVDD_08_08_NT_DR": {"V": Power_Module("PVDD_08_08_NT_DR_V"),
                             "H": Power_Module("PVDD_08_08_NT_DR_H")},
        "PVSS_08_08_NT_DR": {"V": Power_Module("PVSS_08_08_NT_DR_V"),
                             "H": Power_Module("PVSS_08_08_NT_DR_H")},
        "PDVDD_18_18_NT_DR": {"V": Power_Module("PDVDD_18_18_NT_DR_V"),
                              "H": Power_Module("PDVDD_18_18_NT_DR_H")},
        "PDVSS_18_18_NT_DR": {"V": Power_Module("PDVSS_18_18_NT_DR_V"),
                              "H": Power_Module("PDVSS_18_18_NT_DR_H")},
        "PDVDDTIE_18_18_NT_DR": {"V": Power_Module("PDVDDTIE_18_18_NT_DR_V"),
                                 "H": Power_Module("PDVDDTIE_18_18_NT_DR_H")},
        "PBIDIR_18_18_NT_DR": {"V": PBIDIR_Module("PBIDIR_18_18_NT_DR_V"),
                               "H": PBIDIR_Module("PBIDIR_18_18_NT_DR_H")},
        "PINCNP_18_18_NT_DR": {"V": PINCNP_Module("PINCNP_18_18_NT_DR_V"),
                               "H": PINCNP_Module("PINCNP_18_18_NT_DR_H")}
    }
    PinMap["Instance_Name"] = ""
    for i in PinMap.index:
        # Common Pin Mapping and Instance Name
        portMap = (('SNS', SNS), ('RTO', RTO),)
        #    ('DVDD', DVDD_W), ('DVSS', DVSS_W))
        inst = GPIOModulesInstance[PinMap["Cell"][i]][SLbl[PinMap["Side"][i]]]
        direc = SIDE_MAP[PinMap["Side"][i]]
        InstLabel = f"{PinMap['Cell'][i]}_{direc}_cell_{i}"
        PinMap["Instance_Name"][i] = InstLabel
        # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
        # Power ports addition
        # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
        if (PIN_MAP[PinMap["Pin"][i]] in ["VDD", "VSS", "DVDD", "DVSS", "PVDDTIE"]):
            pass
        # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
        # Global Input Ports
        # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
        elif (PIN_MAP[PinMap["Pin"][i]] == "GPortIn"):
            portMap += (("PAD", PortList[PinMap["Remark"][i]]["Port"]),)
            portMap += (("Y", PortList[PinMap["Remark"][i]]["Wire"]),)
            portMap += (("IE", HIGH[tieHighIndex]),)
            tieHighIndex += 1
            portMap += (("IS", LOW[tieLowIndex]),)
            tieLowIndex += 1
            portMap += (("POE", LOW[tieLowIndex]),)
            tieLowIndex += 1
            portMap += (("PO", UNCONN[unconnIndex]),)
            unconnIndex += 1
        # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
        # Global Output Ports
        # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
        elif (PIN_MAP[PinMap["Pin"][i]] == "GPortOut"):
            portMap += (("PAD", PortList[PinMap["Remark"][i]]["Port"]),)
            portMap += (("A", PortList[PinMap["Remark"][i]]["Wire"]),)
            portMap += (("Y", UNCONN[unconnIndex]),)
            unconnIndex += 1
            portMap += (("IE", LOW[tieLowIndex]),)
            tieLowIndex += 1
            portMap += (("OE", HIGH[tieHighIndex]),)
            tieHighIndex += 1
            portMap += (("DS0", HIGH[tieHighIndex]),)
            tieHighIndex += 1
            portMap += (("DS1", HIGH[tieHighIndex]),)
            tieHighIndex += 1
            portMap += (("IS", LOW[tieLowIndex]),)
            tieLowIndex += 1
            portMap += (("PE", LOW[tieLowIndex]),)
            tieLowIndex += 1
            portMap += (("POE", LOW[tieLowIndex]),)
            tieLowIndex += 1
            portMap += (("PS", LOW[tieLowIndex]),)
            tieLowIndex += 1
            portMap += (("SR", LOW[tieLowIndex]),)
            tieLowIndex += 1
            portMap += (("PO", UNCONN[unconnIndex]),)
            unconnIndex += 1
        # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
        # GPIO Ports
        # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
        elif (PIN_MAP[PinMap["Pin"][i]] == "GPIO"):
            BusName = PinMap["Remark"][i].split("[")[0]
            Index = int(PinMap["Remark"][i].split("[")[1][:1])
            portMap += (("PAD", PortList[BusName+"_Y"]["Port"][Index]),)
            for conn in ["Y", "A", "IE", "OE"]:
                portMap += ((conn, PortList[BusName +
                                            f"_{conn}"]["Wire"][Index]),)
            portMap += (("DS0", HIGH[tieHighIndex]),)
            tieHighIndex += 1
            portMap += (("DS1", HIGH[tieHighIndex]),)
            tieHighIndex += 1
            portMap += (("IS", LOW[tieLowIndex]),)
            tieLowIndex += 1
            portMap += (("PE", LOW[tieLowIndex]),)
            tieLowIndex += 1
            portMap += (("POE", LOW[tieLowIndex]),)
            tieLowIndex += 1
            portMap += (("PS", LOW[tieLowIndex]),)
            tieLowIndex += 1
            portMap += (("SR", LOW[tieLowIndex]),)
            tieLowIndex += 1
            portMap += (("PO", UNCONN[unconnIndex]),)
            unconnIndex += 1
        else:
            print("Unknown Port needs...... terminating")
            exit()
        m.Instance(inst, InstLabel, ports=portMap)

    # Adjust unconnected net width
    TIEH_INST = TIE_HIGH()
    TIEL_INST = TIE_LOW()
    for each in range(tieHighIndex):
        m.Instance(TIEH_INST, f"tie_high_{each}", ports=(("Y", HIGH[each]),))
    for each in range(tieLowIndex):
        m.Instance(TIEL_INST, f"tie_low_{each}", ports=(("Y", LOW[each]),))
    UNCONN.width = unconnIndex
    HIGH.width = tieHighIndex
    LOW.width = tieLowIndex
    return m


def TranslatePinNames(df):
    df['Remark'] = df['Remark'].apply(
        lambda x: "gfpga_pad_GPIO[%d]" % int(x[4:]) if "GPIO" in x else x)
    df['Side'] = df['Side'].apply(lambda x: int(x))
    df['Pin'] = df['Pin'].apply(lambda x: int(x))
    df['Number'] = df['Number'].apply(lambda x: int(x))


def LoadData(pathtoCsv=None):
    if pathtoCsv is None:
        pathtoCsv = r'https://docs.google.com/spreadsheets/d/e/2PACX-1vQoLR2KbvU9BOF6PszjTtIrrY7nrb8GlHMlqC_VAjFgGrTF5ToGgPvfDRY-Pj0GjgamkaIglq7kTX7q/pub?gid=85930648&single=true&output=csv'
    df = pd.read_csv(pathtoCsv, encoding='utf8', skiprows=1)
    df.dropna(subset=['Side', ], inplace=True)
    df = df.loc[:, ~df.columns.str.contains('^Unnamed')]
    dfNew = pd.DataFrame(columns=["Side", "Pin", "Number", "Remark", "Cell"])
    for i in range(4):
        dfTemp = pd.DataFrame(df.iloc[:, (5*i):5*(i+1)])
        dfTemp.columns = ["Side", "Pin", "Number", "Remark", "Cell"]
        dfNew = dfNew.append(dfTemp, ignore_index=True)
    return dfNew


def ParseInputVerilog():
    astObj, _ = parse([args.core_netlist])
    ModuleDef = astObj.children()[0].children()[0].children()
    portlist = {}
    for eachPort in ModuleDef[1].ports:
        portlist[eachPort.name] = {"width": 0}

    for eachPort in ModuleDef[2:]:
        if(isinstance(eachPort.children()[0], ast.Input)):
            portlist[eachPort.children()[0].name]["type"] = "Input"
        elif(isinstance(eachPort.children()[0], ast.Output)):
            portlist[eachPort.children()[0].name]["type"] = "Output"
        elif(isinstance(eachPort.children()[0], ast.Inout)):
            portlist[eachPort.children()[0].name]["type"] = "Inout"
        portlist[eachPort.children()[0].name]["width"] = 1 + \
            abs(int(eachPort.children()[0].width.msb.value) -
                int(eachPort.children()[0].width.lsb.value))
    print("* "*20)
    print("\n".join([(f"{port} : " +
                      f"Width : {prop['width']}  " +
                      f"Dir : {prop['type']}") for port, prop in portlist.items()]))
    print("* "*20)
    return portlist
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =


def gpio_cell(name):
    m = vgen.Module(name)
    m.Inout('SNS')
    m.Inout('RTO')
    # m.Inout('DVDD')
    # m.Inout('DVSS')
    return m


def Power_Module(cellName):
    m = gpio_cell(cellName)
    return m


def PINCNP_Module(cellName):
    m = gpio_cell(cellName)
    m.Input("IE")
    m.Input("IS")
    m.Input("PAD")
    m.Input("POE")
    m.Input("PO")
    m.Output("Y")
    return m


def PBIDIR_Module(cellName):
    m = PINCNP_Module(cellName)
    m.Input("A")
    m.Input("DS0")
    m.Input("DS1")
    m.Input("OE")
    m.Input("PE")
    m.Input("PS")
    m.Input("SR")
    return m


def TIE_HIGH():
    m = vgen.Module('TIEHI_X1N_A9PP84TR_C14')
    m.Input("Y")
    return m


def TIE_LOW():
    m = vgen.Module('TIELO_X1N_A9PP84TR_C14')
    m.Input("Y")
    return m


def GPIO_PAD():
    m = vgen.Module('PBP50_18_18_NT_DR')
    m.Input("PAD")
    return m


if __name__ == '__main__':
    main()
    remove_files = ["parsetab.py", "parser.out"]
    for eachFile in remove_files:
        if os.path.isfile(eachFile):
            os.remove(eachFile)
