!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ABSOLUTE	SRC/include/physical_types.h	/^	ABSOLUTE, FRACTIONAL$/;"	e	enum:e_Fc_type
ARCH_TYPES_H	SRC/include/arch_types.h	9;"	d
Aspect	SRC/include/physical_types.h	/^	float Aspect;$/;"	m	struct:s_clb_grid
BEST_CORNER	SRC/fpga_spice_include/spice_types.h	/^ BEST_CORNER,$/;"	e	enum:e_process_corner
BI_DIRECTIONAL	SRC/include/physical_types.h	/^	UNI_DIRECTIONAL, BI_DIRECTIONAL$/;"	e	enum:e_directionality
BOTTOM	SRC/include/sides.h	/^  BOTTOM = 2, $/;"	e	enum:e_side
BOUNDARY	SRC/include/physical_types.h	/^	BOUNDARY = 0, FILL, COL_REPEAT, COL_REL$/;"	e	enum:e_grid_loc_type
BUFSIZE	SRC/include/util.h	23;"	d
C	SRC/include/arch_types_mrfpga.h	/^  float C; $/;"	m	struct:s_memristor_inf
C	SRC/include/arch_types_mrfpga.h	/^  float C;$/;"	m	struct:s_buffer_inf
C	SRC/include/physical_types.h	/^		float C;$/;"	m	union:s_port_power::__anon3
CAD_TYPES_H	SRC/include/cad_types.h	5;"	d
CHECK_RAND	SRC/util.c	734;"	d	file:
CHUNK_SIZE	SRC/util.c	208;"	d	file:
COL_REL	SRC/include/physical_types.h	/^	BOUNDARY = 0, FILL, COL_REPEAT, COL_REL$/;"	e	enum:e_grid_loc_type
COL_REPEAT	SRC/include/physical_types.h	/^	BOUNDARY = 0, FILL, COL_REPEAT, COL_REL$/;"	e	enum:e_grid_loc_type
COMPLETE_INTERC	SRC/include/physical_types.h	/^	COMPLETE_INTERC = 1, DIRECT_INTERC = 2, MUX_INTERC = 3$/;"	e	enum:e_interconnect
CONV	SRC/include/arch_types_mrfpga.h	/^  CONV = 0, MONO, STTRAM, PCRAM_Xie, PCRAM_Pierre, NEM $/;"	e	enum:e_tech_comp
C_internal	SRC/include/physical_types.h	/^	float C_internal; \/*Internal capacitance of the pb *\/$/;"	m	struct:s_pb_type_power
C_ipin_cblock	SRC/include/physical_types.h	/^	float C_ipin_cblock;$/;"	m	struct:s_arch
C_ipin_cblock	SRC/include/physical_types.h	/^	float C_ipin_cblock;$/;"	m	struct:s_timing_inf
C_wire	SRC/include/physical_types.h	/^	float C_wire; \/* Wire capacitance (per meter) *\/$/;"	m	struct:s_clock_network
C_wire	SRC/include/physical_types.h	/^	float C_wire;$/;"	m	struct:s_pb_graph_pin_power
C_wire_local	SRC/include/physical_types.h	/^	float C_wire_local; \/* Capacitance of local interconnect (per meter) *\/$/;"	m	struct:s_power_arch
Chans	SRC/include/physical_types.h	/^	t_chan_width_dist Chans;$/;"	m	struct:s_arch
CheckElement	SRC/read_xml_util.c	/^void CheckElement(INP ezxml_t Node, INP const char *Name) {$/;"	f
Cin	SRC/include/physical_types.h	/^	float Cin;$/;"	m	struct:s_switch_inf
Cmetal	SRC/include/physical_types.h	/^	float Cmetal;$/;"	m	struct:s_segment_inf
CountChildren	SRC/read_xml_util.c	/^extern int CountChildren(INP ezxml_t Node, INP const char *Name,$/;"	f
CountTokens	SRC/ReadLine.c	/^int CountTokens(INP char **Tokens) {$/;"	f
CountTokensInString	SRC/read_xml_util.c	/^extern void CountTokensInString(INP const char *Str, OUTP int *Num,$/;"	f
Cout	SRC/include/physical_types.h	/^	float Cout;$/;"	m	struct:s_switch_inf
CreateModelLibrary	SRC/read_xml_arch_file.c	/^static void CreateModelLibrary(OUTP struct s_arch *arch) {$/;"	f	file:
Cseg_global	SRC/include/arch_types_mrfpga.h	/^  float Cseg_global;$/;"	m	struct:s_arch_mrfpga
DELTA	SRC/include/physical_types.h	/^	UNIFORM, GAUSSIAN, PULSE, DELTA$/;"	e	enum:e_stat
DIRECT_INTERC	SRC/include/physical_types.h	/^	COMPLETE_INTERC = 1, DIRECT_INTERC = 2, MUX_INTERC = 3$/;"	e	enum:e_interconnect
DRIVER	SRC/include/physical_types.h	/^	OPEN = -1, DRIVER = 0, RECEIVER = 1$/;"	e	enum:e_pin_type
Directs	SRC/include/physical_types.h	/^	t_direct_inf *Directs;$/;"	m	struct:s_arch
EMPTY_TYPE	SRC/read_xml_arch_file.c	/^static t_type_ptr EMPTY_TYPE = NULL;$/;"	v	file:
EMPTY_TYPE_INDEX	SRC/include/read_xml_arch_file.h	15;"	d
ERRTAG	SRC/include/util.h	26;"	d
ERR_PORT	SRC/include/logic_types.h	/^	IN_PORT, OUT_PORT, INOUT_PORT, ERR_PORT$/;"	e	enum:PORTS
EZXML_BUFSIZE	SRC/include/ezxml.h	37;"	d
EZXML_DUP	SRC/include/ezxml.h	40;"	d
EZXML_ERRL	SRC/include/ezxml.h	41;"	d
EZXML_NAMEM	SRC/include/ezxml.h	38;"	d
EZXML_NIL	SRC/ezxml.c	/^char *EZXML_NIL[] = { NULL }; \/* empty, null terminated array of strings *\/$/;"	v
EZXML_NOMMAP	SRC/ezxml.c	26;"	d	file:
EZXML_TXTM	SRC/include/ezxml.h	39;"	d
EZXML_WS	SRC/ezxml.c	64;"	d	file:
E_ANNOT_PIN_TO_PIN_CAPACITANCE	SRC/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_CAPACITANCE,$/;"	e	enum:e_pin_to_pin_annotation_type
E_ANNOT_PIN_TO_PIN_CAPACITANCE_C	SRC/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_CAPACITANCE_C = 0$/;"	e	enum:e_pin_to_pin_capacitance_annotations
E_ANNOT_PIN_TO_PIN_CONSTANT	SRC/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_MATRIX = 0, E_ANNOT_PIN_TO_PIN_CONSTANT$/;"	e	enum:e_pin_to_pin_annotation_format
E_ANNOT_PIN_TO_PIN_DELAY	SRC/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY = 0,$/;"	e	enum:e_pin_to_pin_annotation_type
E_ANNOT_PIN_TO_PIN_DELAY_CLOCK_TO_Q_MAX	SRC/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY_CLOCK_TO_Q_MAX,$/;"	e	enum:e_pin_to_pin_delay_annotations
E_ANNOT_PIN_TO_PIN_DELAY_CLOCK_TO_Q_MIN	SRC/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY_CLOCK_TO_Q_MIN,$/;"	e	enum:e_pin_to_pin_delay_annotations
E_ANNOT_PIN_TO_PIN_DELAY_MAX	SRC/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY_MAX,$/;"	e	enum:e_pin_to_pin_delay_annotations
E_ANNOT_PIN_TO_PIN_DELAY_MIN	SRC/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY_MIN = 0,$/;"	e	enum:e_pin_to_pin_delay_annotations
E_ANNOT_PIN_TO_PIN_DELAY_THOLD	SRC/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY_THOLD$/;"	e	enum:e_pin_to_pin_delay_annotations
E_ANNOT_PIN_TO_PIN_DELAY_TSETUP	SRC/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_DELAY_TSETUP,$/;"	e	enum:e_pin_to_pin_delay_annotations
E_ANNOT_PIN_TO_PIN_MATRIX	SRC/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_MATRIX = 0, E_ANNOT_PIN_TO_PIN_CONSTANT$/;"	e	enum:e_pin_to_pin_annotation_format
E_ANNOT_PIN_TO_PIN_MODE_SELECT	SRC/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_MODE_SELECT$/;"	e	enum:e_pin_to_pin_annotation_type
E_ANNOT_PIN_TO_PIN_MODE_SELECT_MODE_NAME	SRC/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_MODE_SELECT_MODE_NAME = 0$/;"	e	enum:e_pin_to_pin_mode_select_annotations
E_ANNOT_PIN_TO_PIN_PACK_PATTERN	SRC/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_PACK_PATTERN,$/;"	e	enum:e_pin_to_pin_annotation_type
E_ANNOT_PIN_TO_PIN_PACK_PATTERN_NAME	SRC/include/physical_types.h	/^	E_ANNOT_PIN_TO_PIN_PACK_PATTERN_NAME = 0$/;"	e	enum:e_pin_to_pin_pack_pattern_annotations
E_CUSTOM_PIN_DISTR	SRC/include/physical_types.h	/^	E_SPREAD_PIN_DISTR = 1, E_CUSTOM_PIN_DISTR = 2$/;"	e	enum:e_pin_location_distr
E_SPREAD_PIN_DISTR	SRC/include/physical_types.h	/^	E_SPREAD_PIN_DISTR = 1, E_CUSTOM_PIN_DISTR = 2$/;"	e	enum:e_pin_location_distr
EchoArch	SRC/read_xml_arch_file.c	/^void EchoArch(INP const char *EchoFile, INP const t_type_descriptor * Types,$/;"	f
FALSE	SRC/include/util.h	/^	FALSE, TRUE$/;"	e	enum:__anon4
FC_ABS	SRC/read_xml_arch_file.c	/^	FC_ABS, FC_FRAC, FC_FULL$/;"	e	enum:Fc_type	file:
FC_FRAC	SRC/read_xml_arch_file.c	/^	FC_ABS, FC_FRAC, FC_FULL$/;"	e	enum:Fc_type	file:
FC_FULL	SRC/read_xml_arch_file.c	/^	FC_ABS, FC_FRAC, FC_FULL$/;"	e	enum:Fc_type	file:
FF_FE	SRC/fpga_spice_include/spice_types.h	/^  FF_RE, FF_FE$/;"	e	enum:e_spice_ff_trigger_type
FF_RE	SRC/fpga_spice_include/spice_types.h	/^  FF_RE, FF_FE$/;"	e	enum:e_spice_ff_trigger_type
FF_size	SRC/include/physical_types.h	/^	float FF_size;$/;"	m	struct:s_power_arch
FILL	SRC/include/physical_types.h	/^	BOUNDARY = 0, FILL, COL_REPEAT, COL_REL$/;"	e	enum:e_grid_loc_type
FILL_TYPE	SRC/read_xml_arch_file.c	/^static t_type_ptr FILL_TYPE = NULL;$/;"	v	file:
FRACTIONAL	SRC/include/physical_types.h	/^	ABSOLUTE, FRACTIONAL$/;"	e	enum:e_Fc_type
FRAGMENT_THRESHOLD	SRC/util.c	209;"	d	file:
FULL	SRC/include/physical_types.h	/^	SUBSET, WILTON, UNIVERSAL, FULL$/;"	e	enum:e_switch_block_type
Fc	SRC/include/physical_types.h	/^	float *Fc; \/* [0..num_pins-1] *\/$/;"	m	struct:s_type_descriptor
Fc_type	SRC/read_xml_arch_file.c	/^enum Fc_type {$/;"	g	file:
FindElement	SRC/read_xml_util.c	/^ezxml_t FindElement(INP ezxml_t Parent, INP const char *Name,$/;"	f
FindFirstElement	SRC/read_xml_util.c	/^ezxml_t FindFirstElement(INP ezxml_t Parent, INP const char *Name,$/;"	f
FindProperty	SRC/read_xml_util.c	/^FindProperty(INP ezxml_t Parent, INP const char *Name, INP boolean Required) {$/;"	f
FreeNode	SRC/read_xml_util.c	/^void FreeNode(INOUTP ezxml_t Node) {$/;"	f
FreeSpice	SRC/read_xml_spice_util.c	/^void FreeSpice(t_spice* spice) {$/;"	f
FreeSpiceMeasParams	SRC/read_xml_spice_util.c	/^void FreeSpiceMeasParams(t_spice_meas_params* meas_params) {$/;"	f
FreeSpiceModel	SRC/read_xml_spice_util.c	/^void FreeSpiceModel(t_spice_model* spice_model) {$/;"	f
FreeSpiceModelBuffer	SRC/read_xml_spice_util.c	/^void FreeSpiceModelBuffer(t_spice_model_buffer* spice_model_buffer) {$/;"	f
FreeSpiceModelNetlist	SRC/read_xml_spice_util.c	/^void FreeSpiceModelNetlist(t_spice_model_netlist* spice_model_netlist) {$/;"	f
FreeSpiceModelPassGateLogic	SRC/read_xml_spice_util.c	/^void FreeSpiceModelPassGateLogic(t_spice_model_pass_gate_logic* spice_model_pass_gate_logic) {$/;"	f
FreeSpiceModelPort	SRC/read_xml_spice_util.c	/^void FreeSpiceModelPort(t_spice_model_port* spice_model_port) {$/;"	f
FreeSpiceModelWireParam	SRC/read_xml_spice_util.c	/^void FreeSpiceModelWireParam(t_spice_model_wire_param* spice_model_wire_param) {$/;"	f
FreeSpiceMonteCarloParams	SRC/read_xml_spice_util.c	/^void FreeSpiceMonteCarloParams(t_spice_mc_params* mc_params) {$/;"	f
FreeSpiceMuxArch	SRC/read_xml_spice_util.c	/^void FreeSpiceMuxArch(t_spice_mux_arch* spice_mux_arch) {$/;"	f
FreeSpiceParams	SRC/read_xml_spice_util.c	/^void FreeSpiceParams(t_spice_params* params) {$/;"	f
FreeSpiceStimulateParams	SRC/read_xml_spice_util.c	/^void FreeSpiceStimulateParams(t_spice_stimulate_params* stimulate_params) {$/;"	f
FreeSpiceVariationParams	SRC/read_xml_spice_util.c	/^void FreeSpiceVariationParams(t_spice_mc_variation_params* mc_variation_params) {$/;"	f
FreeSramInf	SRC/read_xml_spice_util.c	/^void FreeSramInf(t_sram_inf* sram_inf) {$/;"	f
FreeSramInfOrgz	SRC/read_xml_spice_util.c	/^void FreeSramInfOrgz(t_sram_inf_orgz* sram_inf_orgz) {$/;"	f
FreeTokens	SRC/ReadLine.c	/^void FreeTokens(INOUTP char ***TokensPtr) {$/;"	f
Fs	SRC/include/physical_types.h	/^	int Fs;$/;"	m	struct:s_arch
GAUSSIAN	SRC/include/physical_types.h	/^	UNIFORM, GAUSSIAN, PULSE, DELTA$/;"	e	enum:e_stat
GetBooleanProperty	SRC/read_xml_util.c	/^extern boolean GetBooleanProperty(INP ezxml_t Parent, INP char *Name,$/;"	f
GetFloatProperty	SRC/read_xml_util.c	/^extern float GetFloatProperty(INP ezxml_t Parent, INP char *Name,$/;"	f
GetIntProperty	SRC/read_xml_util.c	/^extern int GetIntProperty(INP ezxml_t Parent, INP char *Name,$/;"	f
GetNodeTokens	SRC/read_xml_util.c	/^GetNodeTokens(INP ezxml_t Node) {$/;"	f
H	SRC/include/physical_types.h	/^	int H;$/;"	m	struct:s_clb_grid
IA	SRC/util.c	731;"	d	file:
IC	SRC/util.c	732;"	d	file:
IM	SRC/util.c	733;"	d	file:
INOUTP	SRC/include/util.h	21;"	d
INOUT_PORT	SRC/include/logic_types.h	/^	IN_PORT, OUT_PORT, INOUT_PORT, ERR_PORT$/;"	e	enum:PORTS
INP	SRC/include/util.h	19;"	d
INPUT2INPUT_INTERC	SRC/fpga_spice_include/spice_types.h	/^  INPUT2INPUT_INTERC, $/;"	e	enum:e_spice_pin2pin_interc_type
IN_PORT	SRC/include/logic_types.h	/^	IN_PORT, OUT_PORT, INOUT_PORT, ERR_PORT$/;"	e	enum:PORTS
IO_TYPE	SRC/read_xml_arch_file.c	/^static t_type_ptr IO_TYPE = NULL;$/;"	v	file:
IO_TYPE_INDEX	SRC/include/read_xml_arch_file.h	16;"	d
InitSpice	SRC/read_xml_spice_util.c	/^void InitSpice(t_spice* spice) {$/;"	f
InitSpiceMeasParams	SRC/read_xml_spice_util.c	/^void InitSpiceMeasParams(t_spice_meas_params* meas_params) {$/;"	f
InitSpiceMonteCarloParams	SRC/read_xml_spice_util.c	/^void InitSpiceMonteCarloParams(t_spice_mc_params* mc_params) {$/;"	f
InitSpiceParams	SRC/read_xml_spice_util.c	/^void InitSpiceParams(t_spice_params* params) {$/;"	f
InitSpiceStimulateParams	SRC/read_xml_spice_util.c	/^void InitSpiceStimulateParams(t_spice_stimulate_params* stimulate_params) {$/;"	f
InitSpiceVariationParams	SRC/read_xml_spice_util.c	/^void InitSpiceVariationParams(t_spice_mc_variation_params* mc_variation_params) {$/;"	f
IsAuto	SRC/include/physical_types.h	/^	boolean IsAuto;$/;"	m	struct:s_clb_grid
IsWhitespace	SRC/read_xml_util.c	/^boolean IsWhitespace(char c) {$/;"	f
LATCH_CLASS	SRC/include/physical_types.h	/^	UNKNOWN_CLASS = 0, LUT_CLASS = 1, LATCH_CLASS = 2, MEMORY_CLASS = 3$/;"	e	enum:e_pb_type_class
LEFT	SRC/include/sides.h	/^  LEFT = 3,$/;"	e	enum:e_side
LINKEDLIST_H	SRC/fpga_spice_include/linkedlist.h	2;"	d
LOGIC_TYPES_H	SRC/include/logic_types.h	10;"	d
LUT_CLASS	SRC/include/physical_types.h	/^	UNKNOWN_CLASS = 0, LUT_CLASS = 1, LATCH_CLASS = 2, MEMORY_CLASS = 3$/;"	e	enum:e_pb_type_class
LUT_transistor_size	SRC/include/physical_types.h	/^	float LUT_transistor_size;$/;"	m	struct:s_power_arch
LookaheadNodeTokens	SRC/read_xml_util.c	/^LookaheadNodeTokens(INP ezxml_t Node) {$/;"	f
MAX_CHANNEL_WIDTH	SRC/include/arch_types.h	25;"	d
MEMORY_CLASS	SRC/include/physical_types.h	/^	UNKNOWN_CLASS = 0, LUT_CLASS = 1, LATCH_CLASS = 2, MEMORY_CLASS = 3$/;"	e	enum:e_pb_type_class
MONO	SRC/include/arch_types_mrfpga.h	/^  CONV = 0, MONO, STTRAM, PCRAM_Xie, PCRAM_Pierre, NEM $/;"	e	enum:e_tech_comp
MUX_INTERC	SRC/include/physical_types.h	/^	COMPLETE_INTERC = 1, DIRECT_INTERC = 2, MUX_INTERC = 3$/;"	e	enum:e_interconnect
MY_FREE_FWD_H	SRC/fpga_spice_include/my_free_fwd.h	2;"	d
NEM	SRC/include/arch_types_mrfpga.h	/^  CONV = 0, MONO, STTRAM, PCRAM_Xie, PCRAM_Pierre, NEM $/;"	e	enum:e_tech_comp
NUM_MODELS_IN_LIBRARY	SRC/include/read_xml_arch_file.h	14;"	d
NUM_SIDES	SRC/include/sides.h	/^  NUM_SIDES$/;"	e	enum:e_side
OPEN	SRC/include/physical_types.h	/^	OPEN = -1, DRIVER = 0, RECEIVER = 1$/;"	e	enum:e_pin_type
OUTP	SRC/include/util.h	20;"	d
OUTPUT2OUTPUT_INTERC	SRC/fpga_spice_include/spice_types.h	/^  OUTPUT2OUTPUT_INTERC$/;"	e	enum:e_spice_pin2pin_interc_type
OUT_PORT	SRC/include/logic_types.h	/^	IN_PORT, OUT_PORT, INOUT_PORT, ERR_PORT$/;"	e	enum:PORTS
PB_PIN_CLOCK	SRC/include/physical_types.h	/^	PB_PIN_CLOCK$/;"	e	enum:e_pb_graph_pin_type
PB_PIN_INPAD	SRC/include/physical_types.h	/^	PB_PIN_INPAD,$/;"	e	enum:e_pb_graph_pin_type
PB_PIN_INPUT	SRC/include/physical_types.h	/^	PB_PIN_INPUT,$/;"	e	enum:e_pb_graph_pin_type
PB_PIN_NORMAL	SRC/include/physical_types.h	/^	PB_PIN_NORMAL = 0,$/;"	e	enum:e_pb_graph_pin_type
PB_PIN_OUTPAD	SRC/include/physical_types.h	/^	PB_PIN_OUTPAD,$/;"	e	enum:e_pb_graph_pin_type
PB_PIN_OUTPUT	SRC/include/physical_types.h	/^	PB_PIN_OUTPUT,$/;"	e	enum:e_pb_graph_pin_type
PB_PIN_SEQUENTIAL	SRC/include/physical_types.h	/^	PB_PIN_SEQUENTIAL,$/;"	e	enum:e_pb_graph_pin_type
PB_PIN_TERMINAL	SRC/include/physical_types.h	/^	PB_PIN_TERMINAL,$/;"	e	enum:e_pb_graph_pin_type
PCRAM_Pierre	SRC/include/arch_types_mrfpga.h	/^  CONV = 0, MONO, STTRAM, PCRAM_Xie, PCRAM_Pierre, NEM $/;"	e	enum:e_tech_comp
PCRAM_Xie	SRC/include/arch_types_mrfpga.h	/^  CONV = 0, MONO, STTRAM, PCRAM_Xie, PCRAM_Pierre, NEM $/;"	e	enum:e_tech_comp
PHYSICAL_TYPES_H	SRC/include/physical_types.h	27;"	d
PORTS	SRC/include/logic_types.h	/^enum PORTS {$/;"	g
POWER_BUFFER_TYPE_ABSOLUTE_SIZE	SRC/include/physical_types.h	/^	POWER_BUFFER_TYPE_ABSOLUTE_SIZE$/;"	e	enum:__anon2
POWER_BUFFER_TYPE_AUTO	SRC/include/physical_types.h	/^	POWER_BUFFER_TYPE_AUTO,$/;"	e	enum:__anon2
POWER_BUFFER_TYPE_NONE	SRC/include/physical_types.h	/^	POWER_BUFFER_TYPE_NONE,$/;"	e	enum:__anon2
POWER_BUFFER_TYPE_UNDEFINED	SRC/include/physical_types.h	/^	POWER_BUFFER_TYPE_UNDEFINED = 0,$/;"	e	enum:__anon2
POWER_METHOD_ABSOLUTE	SRC/include/physical_types.h	/^	POWER_METHOD_ABSOLUTE \/* Dynamic: Aboslute, Static: Absolute *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_AUTO_SIZES	SRC/include/physical_types.h	/^	POWER_METHOD_AUTO_SIZES, \/* Transistor-level, auto-sized buffers\/wires *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_C_INTERNAL	SRC/include/physical_types.h	/^	POWER_METHOD_C_INTERNAL, \/* Dynamic: Equiv. Internal capacitance, Static: Absolute *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_IGNORE	SRC/include/physical_types.h	/^	POWER_METHOD_UNDEFINED = 0, POWER_METHOD_IGNORE, \/* Ignore power of this PB, and all children PB *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_SPECIFY_SIZES	SRC/include/physical_types.h	/^	POWER_METHOD_SPECIFY_SIZES, \/* Transistor-level, user-specified buffers\/wires *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_SUM_OF_CHILDREN	SRC/include/physical_types.h	/^	POWER_METHOD_SUM_OF_CHILDREN, \/* Ignore power of this PB, but consider children *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_TOGGLE_PINS	SRC/include/physical_types.h	/^	POWER_METHOD_TOGGLE_PINS, \/* Dynamic: Energy per pin toggle, Static: Absolute *\/$/;"	e	enum:e_power_estimation_method_
POWER_METHOD_UNDEFINED	SRC/include/physical_types.h	/^	POWER_METHOD_UNDEFINED = 0, POWER_METHOD_IGNORE, \/* Ignore power of this PB, and all children PB *\/$/;"	e	enum:e_power_estimation_method_
POWER_WIRE_TYPE_ABSOLUTE_LENGTH	SRC/include/physical_types.h	/^	POWER_WIRE_TYPE_ABSOLUTE_LENGTH,$/;"	e	enum:__anon1
POWER_WIRE_TYPE_AUTO	SRC/include/physical_types.h	/^	POWER_WIRE_TYPE_AUTO$/;"	e	enum:__anon1
POWER_WIRE_TYPE_C	SRC/include/physical_types.h	/^	POWER_WIRE_TYPE_C,$/;"	e	enum:__anon1
POWER_WIRE_TYPE_IGNORED	SRC/include/physical_types.h	/^	POWER_WIRE_TYPE_IGNORED,$/;"	e	enum:__anon1
POWER_WIRE_TYPE_RELATIVE_LENGTH	SRC/include/physical_types.h	/^	POWER_WIRE_TYPE_RELATIVE_LENGTH,$/;"	e	enum:__anon1
POWER_WIRE_TYPE_UNDEFINED	SRC/include/physical_types.h	/^	POWER_WIRE_TYPE_UNDEFINED = 0,$/;"	e	enum:__anon1
PULSE	SRC/include/physical_types.h	/^	UNIFORM, GAUSSIAN, PULSE, DELTA$/;"	e	enum:e_stat
PrintPb_types_rec	SRC/read_xml_arch_file.c	/^static void PrintPb_types_rec(INP FILE * Echo, INP const t_pb_type * pb_type,$/;"	f	file:
ProcessCB_SB	SRC/read_xml_arch_file.c	/^static void ProcessCB_SB(INOUTP ezxml_t Node, INOUTP boolean * list,$/;"	f	file:
ProcessChanWidthDistr	SRC/read_xml_arch_file.c	/^static void ProcessChanWidthDistr(INOUTP ezxml_t Node,$/;"	f	file:
ProcessChanWidthDistrDir	SRC/read_xml_arch_file.c	/^static void ProcessChanWidthDistrDir(INOUTP ezxml_t Node, OUTP t_chan * chan) {$/;"	f	file:
ProcessClocks	SRC/read_xml_arch_file.c	/^static void ProcessClocks(ezxml_t Parent, t_clock_arch * clocks) {$/;"	f	file:
ProcessComplexBlockProps	SRC/read_xml_arch_file.c	/^static void ProcessComplexBlockProps(ezxml_t Node, t_type_descriptor * Type) {$/;"	f	file:
ProcessComplexBlocks	SRC/read_xml_arch_file.c	/^static void ProcessComplexBlocks(INOUTP ezxml_t Node,$/;"	f	file:
ProcessDevice	SRC/read_xml_arch_file.c	/^static void ProcessDevice(INOUTP ezxml_t Node, OUTP struct s_arch *arch,$/;"	f	file:
ProcessDirects	SRC/read_xml_arch_file.c	/^static void ProcessDirects(INOUTP ezxml_t Parent, OUTP t_direct_inf **Directs,$/;"	f	file:
ProcessInterconnect	SRC/read_xml_arch_file.c	/^static void ProcessInterconnect(INOUTP ezxml_t Parent, t_mode * mode) {$/;"	f	file:
ProcessLayout	SRC/read_xml_arch_file.c	/^static void ProcessLayout(INOUTP ezxml_t Node, OUTP struct s_arch *arch) {$/;"	f	file:
ProcessLutClass	SRC/read_xml_arch_file.c	/^void ProcessLutClass(INOUTP t_pb_type *lut_pb_type) {$/;"	f
ProcessMemoryClass	SRC/read_xml_arch_file.c	/^static void ProcessMemoryClass(INOUTP t_pb_type *mem_pb_type) {$/;"	f	file:
ProcessMode	SRC/read_xml_arch_file.c	/^static void ProcessMode(INOUTP ezxml_t Parent, t_mode * mode,$/;"	f	file:
ProcessModels	SRC/read_xml_arch_file.c	/^static void ProcessModels(INOUTP ezxml_t Node, OUTP struct s_arch *arch) {$/;"	f	file:
ProcessMrFPGATiming	SRC/read_xml_mrfpga.c	/^void ProcessMrFPGATiming(INOUTP ezxml_t Cur, $/;"	f
ProcessPb_Type	SRC/read_xml_arch_file.c	/^static void ProcessPb_Type(INOUTP ezxml_t Parent, t_pb_type * pb_type,$/;"	f	file:
ProcessPb_TypePort	SRC/read_xml_arch_file.c	/^static void ProcessPb_TypePort(INOUTP ezxml_t Parent, t_port * port,$/;"	f	file:
ProcessPb_TypePort_Power	SRC/read_xml_arch_file.c	/^static void ProcessPb_TypePort_Power(ezxml_t Parent, t_port * port,$/;"	f	file:
ProcessPb_TypePower	SRC/read_xml_arch_file.c	/^static void ProcessPb_TypePower(ezxml_t Parent, t_pb_type * pb_type) {$/;"	f	file:
ProcessPb_TypePowerEstMethod	SRC/read_xml_arch_file.c	/^static void ProcessPb_TypePowerEstMethod(ezxml_t Parent, t_pb_type * pb_type) {$/;"	f	file:
ProcessPb_TypePowerPinToggle	SRC/read_xml_arch_file.c	/^static void ProcessPb_TypePowerPinToggle(ezxml_t parent, t_pb_type * pb_type) {$/;"	f	file:
ProcessPinToPinAnnotations	SRC/read_xml_arch_file.c	/^static void ProcessPinToPinAnnotations(ezxml_t Parent,$/;"	f	file:
ProcessPower	SRC/read_xml_arch_file.c	/^static void ProcessPower( INOUTP ezxml_t parent,$/;"	f	file:
ProcessSegments	SRC/read_xml_arch_file.c	/^static void ProcessSegments(INOUTP ezxml_t Parent,$/;"	f	file:
ProcessSpiceMCVariationParams	SRC/read_xml_spice.c	/^static void ProcessSpiceMCVariationParams(ezxml_t Parent,$/;"	f	file:
ProcessSpiceMeasParams	SRC/read_xml_spice.c	/^static void ProcessSpiceMeasParams(ezxml_t Parent,$/;"	f	file:
ProcessSpiceModel	SRC/read_xml_spice.c	/^static void ProcessSpiceModel(ezxml_t Parent,$/;"	f	file:
ProcessSpiceModelBuffer	SRC/read_xml_spice.c	/^static void ProcessSpiceModelBuffer(ezxml_t Node,$/;"	f	file:
ProcessSpiceModelDelayInfo	SRC/read_xml_spice.c	/^void ProcessSpiceModelDelayInfo(ezxml_t Node, $/;"	f	file:
ProcessSpiceModelGate	SRC/read_xml_spice.c	/^static void ProcessSpiceModelGate(ezxml_t Node, $/;"	f	file:
ProcessSpiceModelLUT	SRC/read_xml_spice.c	/^static void ProcessSpiceModelLUT(ezxml_t Node, $/;"	f	file:
ProcessSpiceModelMUX	SRC/read_xml_spice.c	/^static void ProcessSpiceModelMUX(ezxml_t Node, $/;"	f	file:
ProcessSpiceModelPassGateLogic	SRC/read_xml_spice.c	/^static void ProcessSpiceModelPassGateLogic(ezxml_t Node,$/;"	f	file:
ProcessSpiceModelPort	SRC/read_xml_spice.c	/^static void ProcessSpiceModelPort(ezxml_t Node,$/;"	f	file:
ProcessSpiceModelPortLutOutputMask	SRC/read_xml_spice.c	/^static void ProcessSpiceModelPortLutOutputMask(ezxml_t Node,$/;"	f	file:
ProcessSpiceModelRRAM	SRC/read_xml_spice.c	/^static void ProcessSpiceModelRRAM(ezxml_t Node, $/;"	f	file:
ProcessSpiceModelWireParam	SRC/read_xml_spice.c	/^static void ProcessSpiceModelWireParam(ezxml_t Parent,$/;"	f	file:
ProcessSpiceMonteCarloParams	SRC/read_xml_spice.c	/^static void ProcessSpiceMonteCarloParams(ezxml_t Parent, $/;"	f	file:
ProcessSpiceParams	SRC/read_xml_spice.c	/^static void ProcessSpiceParams(ezxml_t Parent,$/;"	f	file:
ProcessSpiceSRAM	SRC/read_xml_spice.c	/^void ProcessSpiceSRAM(INOUTP ezxml_t Node, OUTP struct s_arch* arch) {$/;"	f
ProcessSpiceSRAMOrganization	SRC/read_xml_spice.c	/^void ProcessSpiceSRAMOrganization(INOUTP ezxml_t Node, $/;"	f	file:
ProcessSpiceSettings	SRC/read_xml_spice.c	/^void ProcessSpiceSettings(ezxml_t Parent,$/;"	f
ProcessSpiceStimulateParams	SRC/read_xml_spice.c	/^static void ProcessSpiceStimulateParams(ezxml_t Parent,$/;"	f	file:
ProcessSpiceStimulateParamsRiseFall	SRC/read_xml_spice.c	/^static void ProcessSpiceStimulateParamsRiseFall(ezxml_t Parent,$/;"	f	file:
ProcessSpiceTechLibTransistors	SRC/read_xml_spice.c	/^static void ProcessSpiceTechLibTransistors(ezxml_t Parent,$/;"	f	file:
ProcessSpiceTransistorType	SRC/read_xml_spice.c	/^static void ProcessSpiceTransistorType(ezxml_t Parent,$/;"	f	file:
ProcessSwitchSegmentPatterns	SRC/read_xml_arch_file.c	/^static void ProcessSwitchSegmentPatterns(INOUTP ezxml_t Parent,$/;"	f	file:
ProcessSwitches	SRC/read_xml_arch_file.c	/^static void ProcessSwitches(INOUTP ezxml_t Parent,$/;"	f	file:
ProcessTechComp	SRC/read_xml_mrfpga.c	/^ProcessTechComp(INOUTP ezxml_t Node,$/;"	f
ProcessTechHack	SRC/read_xml_mrfpga.c	/^ProcessTechHack(INOUTP ezxml_t Node,$/;"	f
ProcessTechnology	SRC/read_xml_mrfpga.c	/^ProcessTechnology(INOUTP ezxml_t Node,$/;"	f
ProcessWireBuffer	SRC/read_xml_mrfpga.c	/^ProcessWireBuffer(INOUTP ezxml_t Node,$/;"	f
Process_Fc	SRC/read_xml_arch_file.c	/^static void Process_Fc(ezxml_t Node, t_type_descriptor * Type) {$/;"	f	file:
ProcessmrFPGA	SRC/read_xml_mrfpga.c	/^ProcessmrFPGA(INOUTP ezxml_t Node,$/;"	f
R	SRC/include/arch_types_mrfpga.h	/^  float R; $/;"	m	struct:s_memristor_inf
R	SRC/include/arch_types_mrfpga.h	/^  float R;$/;"	m	struct:s_buffer_inf
R	SRC/include/physical_types.h	/^	float R;$/;"	m	struct:s_switch_inf
READLINE_H	SRC/include/ReadLine.h	2;"	d
READ_XML_ARCH_FILE_H	SRC/include/read_xml_arch_file.h	2;"	d
READ_XML_SPICE_UTIL_H	SRC/fpga_spice_include/read_xml_spice_util.h	2;"	d
READ_XML_UTIL_H	SRC/include/read_xml_util.h	2;"	d
RECEIVER	SRC/include/physical_types.h	/^	OPEN = -1, DRIVER = 0, RECEIVER = 1$/;"	e	enum:e_pin_type
RIGHT	SRC/include/sides.h	/^  RIGHT = 1, $/;"	e	enum:e_side
R_minW_nmos	SRC/include/physical_types.h	/^	float R_minW_nmos;$/;"	m	struct:s_arch
R_minW_pmos	SRC/include/physical_types.h	/^	float R_minW_pmos;$/;"	m	struct:s_arch
R_opin_cblock	SRC/include/arch_types_mrfpga.h	/^  float R_opin_cblock;$/;"	m	struct:s_arch_mrfpga
R_opin_cblock	SRC/include/physical_types.h	/^    float R_opin_cblock;$/;"	m	struct:s_timing_inf
ReadLineTokens	SRC/ReadLine.c	/^ReadLineTokens(INOUTP FILE * InFile, INOUTP int *LineNum) {$/;"	f
Rmetal	SRC/include/physical_types.h	/^	float Rmetal;$/;"	m	struct:s_segment_inf
Rseg_global	SRC/include/arch_types_mrfpga.h	/^  float Rseg_global;$/;"	m	struct:s_arch_mrfpga
SBType	SRC/include/physical_types.h	/^	enum e_switch_block_type SBType;$/;"	m	struct:s_arch	typeref:enum:s_arch::e_switch_block_type
SDCFile	SRC/include/physical_types.h	/^	char * SDCFile; \/* only here for convenience of passing to path_delay.c *\/$/;"	m	struct:s_timing_inf
SIDES_H	SRC/include/sides.h	2;"	d
SPICE_ABS	SRC/fpga_spice_include/spice_types.h	/^  SPICE_FRAC, SPICE_ABS$/;"	e	enum:e_spice_accuracy_type
SPICE_CB_MUX_TB	SRC/fpga_spice_include/spice_types.h	/^  SPICE_CB_MUX_TB, $/;"	e	enum:e_spice_tb_type
SPICE_CB_TB	SRC/fpga_spice_include/spice_types.h	/^  SPICE_CB_TB,$/;"	e	enum:e_spice_tb_type
SPICE_FRAC	SRC/fpga_spice_include/spice_types.h	/^  SPICE_FRAC, SPICE_ABS$/;"	e	enum:e_spice_accuracy_type
SPICE_GRID_TB	SRC/fpga_spice_include/spice_types.h	/^  SPICE_GRID_TB,$/;"	e	enum:e_spice_tb_type
SPICE_HARDLOGIC_TB	SRC/fpga_spice_include/spice_types.h	/^  SPICE_HARDLOGIC_TB$/;"	e	enum:e_spice_tb_type
SPICE_IO_TB	SRC/fpga_spice_include/spice_types.h	/^  SPICE_IO_TB,$/;"	e	enum:e_spice_tb_type
SPICE_LIB_ACADEMIA	SRC/fpga_spice_include/spice_types.h	/^  SPICE_LIB_ACADEMIA$/;"	e	enum:e_spice_tech_lib_type
SPICE_LIB_INDUSTRY	SRC/fpga_spice_include/spice_types.h	/^  SPICE_LIB_INDUSTRY,$/;"	e	enum:e_spice_tech_lib_type
SPICE_LUT_TB	SRC/fpga_spice_include/spice_types.h	/^  SPICE_LUT_TB,$/;"	e	enum:e_spice_tb_type
SPICE_MODEL_BUF_BUF	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_BUF_BUF$/;"	e	enum:e_spice_model_buffer_type
SPICE_MODEL_BUF_INV	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_BUF_INV, $/;"	e	enum:e_spice_model_buffer_type
SPICE_MODEL_CHAN_WIRE	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_CHAN_WIRE, $/;"	e	enum:e_spice_model_type
SPICE_MODEL_DELAY_FALL	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_DELAY_FALL$/;"	e	enum:spice_model_delay_type
SPICE_MODEL_DELAY_RISE	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_DELAY_RISE, $/;"	e	enum:spice_model_delay_type
SPICE_MODEL_DESIGN_CMOS	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_DESIGN_CMOS, $/;"	e	enum:e_spice_model_design_tech
SPICE_MODEL_DESIGN_RRAM	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_DESIGN_RRAM$/;"	e	enum:e_spice_model_design_tech
SPICE_MODEL_FF	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_FF, $/;"	e	enum:e_spice_model_type
SPICE_MODEL_GATE	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_GATE $/;"	e	enum:e_spice_model_type
SPICE_MODEL_GATE_AND	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_GATE_AND, $/;"	e	enum:e_spice_model_gate_type
SPICE_MODEL_GATE_OR	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_GATE_OR$/;"	e	enum:e_spice_model_gate_type
SPICE_MODEL_HARDLOGIC	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_HARDLOGIC,$/;"	e	enum:e_spice_model_type
SPICE_MODEL_INVBUF	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_INVBUF, $/;"	e	enum:e_spice_model_type
SPICE_MODEL_IOPAD	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_IOPAD, $/;"	e	enum:e_spice_model_type
SPICE_MODEL_LUT	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_LUT, $/;"	e	enum:e_spice_model_type
SPICE_MODEL_MUX	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_MUX, $/;"	e	enum:e_spice_model_type
SPICE_MODEL_PASSGATE	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_PASSGATE, $/;"	e	enum:e_spice_model_type
SPICE_MODEL_PASS_GATE_TRANSISTOR	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_PASS_GATE_TRANSISTOR$/;"	e	enum:e_spice_model_pass_gate_logic_type
SPICE_MODEL_PASS_GATE_TRANSMISSION	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_PASS_GATE_TRANSMISSION, $/;"	e	enum:e_spice_model_pass_gate_logic_type
SPICE_MODEL_PORT_BL	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_PORT_BL,$/;"	e	enum:e_spice_model_port_type
SPICE_MODEL_PORT_BLB	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_PORT_BLB,$/;"	e	enum:e_spice_model_port_type
SPICE_MODEL_PORT_CLOCK	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_PORT_CLOCK, $/;"	e	enum:e_spice_model_port_type
SPICE_MODEL_PORT_INOUT	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_PORT_INOUT, $/;"	e	enum:e_spice_model_port_type
SPICE_MODEL_PORT_INPUT	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_PORT_INPUT, $/;"	e	enum:e_spice_model_port_type
SPICE_MODEL_PORT_OUTPUT	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_PORT_OUTPUT, $/;"	e	enum:e_spice_model_port_type
SPICE_MODEL_PORT_SRAM	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_PORT_SRAM,$/;"	e	enum:e_spice_model_port_type
SPICE_MODEL_PORT_WL	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_PORT_WL,$/;"	e	enum:e_spice_model_port_type
SPICE_MODEL_PORT_WLB	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_PORT_WLB$/;"	e	enum:e_spice_model_port_type
SPICE_MODEL_SCFF	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_SCFF,$/;"	e	enum:e_spice_model_type
SPICE_MODEL_SRAM	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_SRAM, $/;"	e	enum:e_spice_model_type
SPICE_MODEL_STRUCTURE_CROSSBAR	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_STRUCTURE_CROSSBAR $/;"	e	enum:e_spice_model_structure
SPICE_MODEL_STRUCTURE_MULTILEVEL	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_STRUCTURE_MULTILEVEL, $/;"	e	enum:e_spice_model_structure
SPICE_MODEL_STRUCTURE_ONELEVEL	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_STRUCTURE_ONELEVEL, $/;"	e	enum:e_spice_model_structure
SPICE_MODEL_STRUCTURE_TREE	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_STRUCTURE_TREE, $/;"	e	enum:e_spice_model_structure
SPICE_MODEL_WIRE	SRC/fpga_spice_include/spice_types.h	/^  SPICE_MODEL_WIRE, $/;"	e	enum:e_spice_model_type
SPICE_PB_MUX_TB	SRC/fpga_spice_include/spice_types.h	/^  SPICE_PB_MUX_TB, $/;"	e	enum:e_spice_tb_type
SPICE_PB_PORT_CLOCK	SRC/fpga_spice_include/spice_types.h	/^  SPICE_PB_PORT_CLOCK$/;"	e	enum:e_spice_pb_port_type
SPICE_PB_PORT_INPUT	SRC/fpga_spice_include/spice_types.h	/^  SPICE_PB_PORT_INPUT,$/;"	e	enum:e_spice_pb_port_type
SPICE_PB_PORT_OUTPUT	SRC/fpga_spice_include/spice_types.h	/^  SPICE_PB_PORT_OUTPUT,$/;"	e	enum:e_spice_pb_port_type
SPICE_SB_MUX_TB	SRC/fpga_spice_include/spice_types.h	/^  SPICE_SB_MUX_TB, $/;"	e	enum:e_spice_tb_type
SPICE_SB_TB	SRC/fpga_spice_include/spice_types.h	/^  SPICE_SB_TB,$/;"	e	enum:e_spice_tb_type
SPICE_SRAM_MEMORY_BANK	SRC/fpga_spice_include/spice_types.h	/^  SPICE_SRAM_MEMORY_BANK$/;"	e	enum:e_sram_orgz
SPICE_SRAM_SCAN_CHAIN	SRC/fpga_spice_include/spice_types.h	/^  SPICE_SRAM_SCAN_CHAIN,$/;"	e	enum:e_sram_orgz
SPICE_SRAM_STANDALONE	SRC/fpga_spice_include/spice_types.h	/^  SPICE_SRAM_STANDALONE,$/;"	e	enum:e_sram_orgz
SPICE_TRANS_IO_NMOS	SRC/fpga_spice_include/spice_types.h	/^  SPICE_TRANS_IO_NMOS, $/;"	e	enum:e_spice_trans_type
SPICE_TRANS_IO_PMOS	SRC/fpga_spice_include/spice_types.h	/^  SPICE_TRANS_IO_PMOS$/;"	e	enum:e_spice_trans_type
SPICE_TRANS_NMOS	SRC/fpga_spice_include/spice_types.h	/^  SPICE_TRANS_NMOS, $/;"	e	enum:e_spice_trans_type
SPICE_TRANS_PMOS	SRC/fpga_spice_include/spice_types.h	/^  SPICE_TRANS_PMOS, $/;"	e	enum:e_spice_trans_type
SPICE_TYPES_H	SRC/fpga_spice_include/spice_types.h	2;"	d
STTRAM	SRC/include/arch_types_mrfpga.h	/^  CONV = 0, MONO, STTRAM, PCRAM_Xie, PCRAM_Pierre, NEM $/;"	e	enum:e_tech_comp
SUBSET	SRC/include/physical_types.h	/^	SUBSET, WILTON, UNIVERSAL, FULL$/;"	e	enum:e_switch_block_type
SWSEG_UNBUF_CB	SRC/include/physical_types.h	/^  SWSEG_UNBUF_SB, SWSEG_UNBUF_CB$/;"	e	enum:e_swseg_pattern_type
SWSEG_UNBUF_SB	SRC/include/physical_types.h	/^  SWSEG_UNBUF_SB, SWSEG_UNBUF_CB$/;"	e	enum:e_swseg_pattern_type
Segments	SRC/include/physical_types.h	/^	t_segment_inf * Segments;$/;"	m	struct:s_arch
SetupEmptyType	SRC/read_xml_arch_file.c	/^static void SetupEmptyType(void) {$/;"	f	file:
SetupGridLocations	SRC/read_xml_arch_file.c	/^static void SetupGridLocations(ezxml_t Locations, t_type_descriptor * Type) {$/;"	f	file:
SetupPinEquivalenceAutoDetect	SRC/read_xml_arch_file.c	/^void SetupPinEquivalenceAutoDetect(ezxml_t Parent, t_type_descriptor* Type) {$/;"	f	file:
SetupPinLocationsAndPinClasses	SRC/read_xml_arch_file.c	/^static void SetupPinLocationsAndPinClasses(ezxml_t Locations,$/;"	f	file:
Side	SRC/include/sides.h	/^class Side {$/;"	c
Side	SRC/sides.cpp	/^Side::Side() {$/;"	f	class:Side
Side	SRC/sides.cpp	/^Side::Side(enum e_side side) {$/;"	f	class:Side
Side	SRC/sides.cpp	/^Side::Side(size_t side) { $/;"	f	class:Side
Switches	SRC/include/physical_types.h	/^	struct s_switch_inf *Switches;$/;"	m	struct:s_arch	typeref:struct:s_arch::s_switch_inf
SyncModelsPbTypes	SRC/read_xml_arch_file.c	/^static void SyncModelsPbTypes(INOUTP struct s_arch *arch,$/;"	f	file:
SyncModelsPbTypes_rec	SRC/read_xml_arch_file.c	/^static void SyncModelsPbTypes_rec(INOUTP struct s_arch *arch,$/;"	f	file:
TOKENS	SRC/include/arch_types.h	19;"	d
TOP	SRC/include/sides.h	/^  TOP = 0, $/;"	e	enum:e_side
TRUE	SRC/include/util.h	/^	FALSE, TRUE$/;"	e	enum:__anon4
TYPICAL_CORNER	SRC/fpga_spice_include/spice_types.h	/^ TYPICAL_CORNER,$/;"	e	enum:e_process_corner
T_ipin_cblock	SRC/include/physical_types.h	/^	float T_ipin_cblock;$/;"	m	struct:s_arch
T_ipin_cblock	SRC/include/physical_types.h	/^	float T_ipin_cblock;$/;"	m	struct:s_timing_inf
T_opin_cblock	SRC/include/arch_types_mrfpga.h	/^  float T_opin_cblock;$/;"	m	struct:s_arch_mrfpga
T_opin_cblock	SRC/include/physical_types.h	/^    float T_opin_cblock;$/;"	m	struct:s_timing_inf
Tdel	SRC/include/arch_types_mrfpga.h	/^  float Tdel; $/;"	m	struct:s_memristor_inf
Tdel	SRC/include/arch_types_mrfpga.h	/^  float Tdel;$/;"	m	struct:s_buffer_inf
Tdel	SRC/include/physical_types.h	/^	float Tdel;$/;"	m	struct:s_switch_inf
UNDEFINED	SRC/include/arch_types.h	22;"	d
UNIFORM	SRC/include/physical_types.h	/^	UNIFORM, GAUSSIAN, PULSE, DELTA$/;"	e	enum:e_stat
UNIVERSAL	SRC/include/physical_types.h	/^	SUBSET, WILTON, UNIVERSAL, FULL$/;"	e	enum:e_switch_block_type
UNI_DIRECTIONAL	SRC/include/physical_types.h	/^	UNI_DIRECTIONAL, BI_DIRECTIONAL$/;"	e	enum:e_directionality
UNKNOWN_CLASS	SRC/include/physical_types.h	/^	UNKNOWN_CLASS = 0, LUT_CLASS = 1, LATCH_CLASS = 2, MEMORY_CLASS = 3$/;"	e	enum:e_pb_type_class
UTIL_H	SRC/include/util.h	2;"	d
UpdateAndCheckModels	SRC/read_xml_arch_file.c	/^static void UpdateAndCheckModels(INOUTP struct s_arch *arch) {$/;"	f	file:
VPR_VERSION	SRC/include/arch_types.h	16;"	d
W	SRC/include/physical_types.h	/^	int W;$/;"	m	struct:s_clb_grid
WARNTAG	SRC/include/util.h	27;"	d
WILTON	SRC/include/physical_types.h	/^	SUBSET, WILTON, UNIVERSAL, FULL$/;"	e	enum:e_switch_block_type
WIRE_MODEL_PIE	SRC/fpga_spice_include/spice_types.h	/^  WIRE_MODEL_PIE,$/;"	e	enum:e_wire_model_type
WIRE_MODEL_T	SRC/fpga_spice_include/spice_types.h	/^  WIRE_MODEL_T$/;"	e	enum:e_wire_model_type
WORST_CORNER	SRC/fpga_spice_include/spice_types.h	/^ WORST_CORNER$/;"	e	enum:e_process_corner
XmlReadArch	SRC/read_xml_arch_file.c	/^void XmlReadArch(INP const char *ArchFile, INP boolean timing_enabled,$/;"	f
_EZXML_H	SRC/include/ezxml.h	26;"	d
abs_variation	SRC/fpga_spice_include/spice_types.h	/^  float abs_variation;$/;"	m	struct:s_spice_mc_variation_params
absolute_length	SRC/include/physical_types.h	/^		float absolute_length;$/;"	m	union:s_port_power::__anon3
absolute_power_per_instance	SRC/include/physical_types.h	/^	t_power_usage absolute_power_per_instance; \/* User-provided absolute power per block *\/$/;"	m	struct:s_pb_type_power
accuracy	SRC/fpga_spice_include/spice_types.h	/^  float accuracy;$/;"	m	struct:s_spice_meas_params
accuracy_type	SRC/fpga_spice_include/spice_types.h	/^  enum e_spice_accuracy_type accuracy_type;$/;"	m	struct:s_spice_meas_params	typeref:enum:s_spice_meas_params::e_spice_accuracy_type
add_const_input	SRC/fpga_spice_include/spice_types.h	/^  boolean add_const_input;$/;"	m	struct:s_spice_model_mux
addr	SRC/fpga_spice_include/spice_types.h	/^  int addr; \/* Address to write the value *\/$/;"	m	struct:s_conf_bit
advanced_rram_design	SRC/fpga_spice_include/spice_types.h	/^  boolean advanced_rram_design;$/;"	m	struct:s_spice_model_mux
alloc_and_load_default_child_for_pb_type	SRC/read_xml_arch_file.c	/^static void alloc_and_load_default_child_for_pb_type( INOUTP t_pb_type *pb_type,$/;"	f	file:
alloc_ivector_and_copy_int_list	SRC/util.c	/^void alloc_ivector_and_copy_int_list(t_linked_int ** list_head_ptr,$/;"	f
alloc_matrix	SRC/util.c	/^alloc_matrix(int nrmin, int nrmax, int ncmin, int ncmax, size_t elsize) {$/;"	f
alloc_matrix3	SRC/util.c	/^alloc_matrix3(int nrmin, int nrmax, int ncmin, int ncmax, int ndmin, int ndmax,$/;"	f
alloc_matrix4	SRC/util.c	/^alloc_matrix4(int nrmin, int nrmax, int ncmin, int ncmax, int ndmin, int ndmax,$/;"	f
annotations	SRC/include/physical_types.h	/^	t_pin_to_pin_annotation *annotations; \/* [0..num_annotations-1] *\/$/;"	m	struct:s_interconnect
annotations	SRC/include/physical_types.h	/^	t_pin_to_pin_annotation *annotations; \/* [0..num_annotations-1] *\/$/;"	m	struct:s_pb_type
arch_mrfpga	SRC/include/physical_types.h	/^    t_arch_mrfpga arch_mrfpga;$/;"	m	struct:s_arch
area	SRC/fpga_spice_include/spice_types.h	/^  float area; \/\/Xifan TANG$/;"	m	struct:s_sram_inf
area	SRC/include/physical_types.h	/^	float area;$/;"	m	struct:s_type_descriptor
attr	SRC/include/ezxml.h	/^	char ***attr; \/* default attributes *\/$/;"	m	struct:ezxml_root
attr	SRC/include/ezxml.h	/^	char **attr; \/* tag attributes { name, value, name, value, ... NULL } *\/$/;"	m	struct:ezxml
auto_select_sim_num_clk_cycle	SRC/fpga_spice_include/spice_types.h	/^  int auto_select_sim_num_clk_cycle;$/;"	m	struct:s_spice_meas_params
autosize_buffer	SRC/include/physical_types.h	/^	boolean autosize_buffer; \/* autosize clock buffers *\/$/;"	m	struct:s_clock_network
base_cost	SRC/include/cad_types.h	/^	float base_cost; \/* base cost of pattern eg. If a group of logical blocks match a pattern of smaller primitives, that is better than the same group using bigger primitives *\/$/;"	m	struct:s_pack_patterns
base_cost	SRC/include/cad_types.h	/^	float base_cost; \/* cost independant of current status of packing *\/$/;"	m	struct:s_cluster_placement_primitive
bl	SRC/fpga_spice_include/spice_types.h	/^  t_conf_bit* bl;$/;"	m	struct:s_conf_bit_info
blif_model	SRC/include/physical_types.h	/^	char *blif_model;$/;"	m	struct:s_pb_type
block_id	SRC/include/cad_types.h	/^	int block_id;$/;"	m	struct:s_pack_pattern_block
boolean	SRC/include/util.h	/^typedef int boolean;$/;"	t
boolean	SRC/include/util.h	/^} boolean;$/;"	t	typeref:enum:__anon4
buf_size	SRC/include/physical_types.h	/^	float buf_size;$/;"	m	struct:s_switch_inf
buffer_info	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_buffer* buffer_info;$/;"	m	struct:s_spice_model_design_tech_info
buffer_size	SRC/include/physical_types.h	/^	float buffer_size; \/* if not autosized, the clock buffer size *\/$/;"	m	struct:s_clock_network
buffer_size	SRC/include/physical_types.h	/^	float buffer_size;$/;"	m	struct:s_pb_graph_pin_power
buffer_size	SRC/include/physical_types.h	/^	float buffer_size;$/;"	m	struct:s_port_power
buffer_type	SRC/include/physical_types.h	/^	e_power_buffer_type buffer_type;$/;"	m	struct:s_port_power
buffered	SRC/include/physical_types.h	/^	boolean buffered;$/;"	m	struct:s_switch_inf
c_str	SRC/sides.cpp	/^const char* Side::c_str() const { $/;"	f	class:Side
cap_val	SRC/fpga_spice_include/spice_types.h	/^  float cap_val; $/;"	m	struct:s_spice_model_wire_param
capacitance	SRC/include/physical_types.h	/^	float capacitance;$/;"	m	struct:s_pb_graph_edge
capacity	SRC/include/physical_types.h	/^	int capacity;$/;"	m	struct:s_type_descriptor
captab	SRC/fpga_spice_include/spice_types.h	/^  int captab;$/;"	m	struct:s_spice_params
cat_llists	SRC/linkedlist.c	/^t_llist* cat_llists(t_llist* head1,$/;"	f
cb	SRC/include/physical_types.h	/^	boolean *cb;$/;"	m	struct:s_segment_inf
cb_len	SRC/include/physical_types.h	/^	int cb_len;$/;"	m	struct:s_segment_inf
cb_switches	SRC/include/physical_types.h	/^    t_switch_inf* cb_switches;$/;"	m	struct:s_arch
cb_type_descriptors	SRC/read_xml_arch_file.c	/^static struct s_type_descriptor *cb_type_descriptors;$/;"	v	typeref:struct:s_type_descriptor	file:
cbx_index_high	SRC/fpga_spice_include/spice_types.h	/^  int** cbx_index_high;$/;"	m	struct:s_spice_model
cbx_index_low	SRC/fpga_spice_include/spice_types.h	/^  int** cbx_index_low;$/;"	m	struct:s_spice_model
cby_index_high	SRC/fpga_spice_include/spice_types.h	/^  int** cby_index_high;$/;"	m	struct:s_spice_model
cby_index_low	SRC/fpga_spice_include/spice_types.h	/^  int** cby_index_low;$/;"	m	struct:s_spice_model
chain_name	SRC/include/physical_types.h	/^	char *chain_name;$/;"	m	struct:s_port
chain_root_pin	SRC/include/cad_types.h	/^	t_pb_graph_pin *chain_root_pin; \/* pointer to logic block input pin that drives this chain from the preceding logic block *\/	$/;"	m	struct:s_pack_patterns
chan_length	SRC/fpga_spice_include/spice_types.h	/^  float chan_length;$/;"	m	struct:s_spice_transistor_type
chan_width_io	SRC/include/physical_types.h	/^	float chan_width_io;$/;"	m	struct:s_chan_width_dist
chan_x_dist	SRC/include/physical_types.h	/^	t_chan chan_x_dist;$/;"	m	struct:s_chan_width_dist
chan_y_dist	SRC/include/physical_types.h	/^	t_chan chan_y_dist;$/;"	m	struct:s_chan_width_dist
check_dptr_exist_in_llist	SRC/linkedlist.c	/^boolean check_dptr_exist_in_llist(t_llist* head, void* data_ptr) {$/;"	f
check_spice_models	SRC/read_xml_spice.c	/^static void check_spice_models(int num_spice_model,$/;"	f	file:
check_tech_lib	SRC/read_xml_spice.c	/^static void check_tech_lib(t_spice_tech_lib tech_lib, $/;"	f	file:
child	SRC/include/ezxml.h	/^	ezxml_t child; \/* head of sub tag list, NULL if none *\/$/;"	m	struct:ezxml
child_pb_graph_nodes	SRC/include/physical_types.h	/^	struct s_pb_graph_node ***child_pb_graph_nodes; \/* [0..num_modes-1][0..num_pb_type_in_mode-1][0..num_pb-1] *\/$/;"	m	struct:s_pb_graph_node	typeref:struct:s_pb_graph_node::s_pb_graph_node
chunk_ptr_head	SRC/include/util.h	/^	struct s_linked_vptr *chunk_ptr_head; $/;"	m	struct:s_chunk	typeref:struct:s_chunk::s_linked_vptr
class_inf	SRC/include/physical_types.h	/^	struct s_class *class_inf; \/* [0..num_class-1] *\/$/;"	m	struct:s_type_descriptor	typeref:struct:s_type_descriptor::s_class
class_type	SRC/include/physical_types.h	/^	enum e_pb_type_class class_type;$/;"	m	struct:s_pb_type	typeref:enum:s_pb_type::e_pb_type_class
clb_grid	SRC/include/physical_types.h	/^	struct s_clb_grid clb_grid;$/;"	m	struct:s_arch	typeref:struct:s_arch::s_clb_grid
clock	SRC/include/physical_types.h	/^	char * clock;$/;"	m	struct:s_pin_to_pin_annotation
clock_inf	SRC/include/physical_types.h	/^	t_clock_network *clock_inf; \/* Details about each clock *\/$/;"	m	struct:s_clock_arch
clock_pins	SRC/include/physical_types.h	/^	t_pb_graph_pin **clock_pins; \/* [0..num_clock_ports-1] [0..num_port_pins-1]*\/$/;"	m	struct:s_pb_graph_node
clock_slew_fall_time	SRC/fpga_spice_include/spice_types.h	/^  float clock_slew_fall_time;  $/;"	m	struct:s_spice_stimulate_params
clock_slew_fall_type	SRC/fpga_spice_include/spice_types.h	/^  enum e_spice_accuracy_type clock_slew_fall_type;$/;"	m	struct:s_spice_stimulate_params	typeref:enum:s_spice_stimulate_params::e_spice_accuracy_type
clock_slew_rise_time	SRC/fpga_spice_include/spice_types.h	/^  float clock_slew_rise_time;  $/;"	m	struct:s_spice_stimulate_params
clock_slew_rise_type	SRC/fpga_spice_include/spice_types.h	/^  enum e_spice_accuracy_type clock_slew_rise_type;$/;"	m	struct:s_spice_stimulate_params	typeref:enum:s_spice_stimulate_params::e_spice_accuracy_type
clocks	SRC/include/physical_types.h	/^	t_clock_arch * clocks;$/;"	m	struct:s_arch
close	SRC/ezxml.c	61;"	d	file:
cluster_placement_primitive	SRC/include/physical_types.h	/^	struct s_cluster_placement_primitive *cluster_placement_primitive; \/* pointer to indexing structure useful during packing stage *\/$/;"	m	struct:s_pb_graph_node	typeref:struct:s_pb_graph_node::s_cluster_placement_primitive
cmos_variation	SRC/fpga_spice_include/spice_types.h	/^  t_spice_mc_variation_params cmos_variation;$/;"	m	struct:s_spice_mc_params
cnt	SRC/fpga_spice_include/spice_types.h	/^  int cnt; \/* Used in mux_testbench only*\/$/;"	m	struct:s_spice_mux_model
cnt	SRC/fpga_spice_include/spice_types.h	/^  int cnt;$/;"	m	struct:s_spice_model
col_rel	SRC/include/physical_types.h	/^	float col_rel;$/;"	m	struct:s_grid_loc_def
conf_bit_head	SRC/fpga_spice_include/spice_types.h	/^  t_llist* conf_bit_head; $/;"	m	struct:s_sram_orgz_info
connections	SRC/include/cad_types.h	/^	struct s_pack_pattern_connections *connections; \/* linked list of connections of logic blocks in pattern *\/$/;"	m	struct:s_pack_pattern_block	typeref:struct:s_pack_pattern_block::s_pack_pattern_connections
const_input_val	SRC/fpga_spice_include/spice_types.h	/^  int const_input_val;$/;"	m	struct:s_spice_model_mux
cont	SRC/util.c	/^static int cont; \/* line continued? *\/$/;"	v	file:
create_llist	SRC/linkedlist.c	/^t_llist* create_llist(int len) {$/;"	f
cur	SRC/include/ezxml.h	/^	ezxml_t cur; \/* current xml tree insertion point *\/$/;"	m	struct:ezxml_root
current_random	SRC/util.c	/^static unsigned int current_random = 0;$/;"	v	file:
data	SRC/include/util.h	/^	int data;$/;"	m	struct:s_linked_int
data_vptr	SRC/include/util.h	/^	void *data_vptr;$/;"	m	struct:s_linked_vptr
dc	SRC/include/physical_types.h	/^	float dc;$/;"	m	struct:s_chan
default_mode_num_conf_bits	SRC/include/physical_types.h	/^    int default_mode_num_conf_bits;$/;"	m	struct:s_pb_type
default_mode_num_iopads	SRC/include/physical_types.h	/^    int default_mode_num_iopads;$/;"	m	struct:s_pb_type
default_mode_num_mode_bits	SRC/include/physical_types.h	/^    int default_mode_num_mode_bits;$/;"	m	struct:s_pb_type
default_mode_num_reserved_conf_bits	SRC/include/physical_types.h	/^    int default_mode_num_reserved_conf_bits;$/;"	m	struct:s_pb_type
default_val	SRC/fpga_spice_include/spice_types.h	/^  int default_val;$/;"	m	struct:s_spice_model_port
define_idle_mode	SRC/include/physical_types.h	/^    int define_idle_mode;   $/;"	m	struct:s_mode
define_physical_mode	SRC/include/physical_types.h	/^    int define_physical_mode;   $/;"	m	struct:s_mode
delay_info	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_delay_info* delay_info;$/;"	m	struct:s_spice_model
delay_max	SRC/include/physical_types.h	/^	float delay_max;$/;"	m	struct:s_pb_graph_edge
delay_min	SRC/include/physical_types.h	/^	float delay_min;$/;"	m	struct:s_pb_graph_edge
delete_in_vptr_list	SRC/util.c	/^delete_in_vptr_list(struct s_linked_vptr *head) {$/;"	f
dens	SRC/include/physical_types.h	/^	float dens; \/* Switching density of net assigned to this clock *\/$/;"	m	struct:s_clock_network
density	SRC/fpga_spice_include/spice_types.h	/^  float density;$/;"	m	struct:s_spice_net_info
depth	SRC/include/physical_types.h	/^	int depth; \/* depth of pb_type *\/$/;"	m	struct:s_pb_type
design_tech	SRC/fpga_spice_include/spice_types.h	/^  enum e_spice_model_design_tech design_tech;$/;"	m	struct:s_spice_model	typeref:enum:s_spice_model::e_spice_model_design_tech
design_tech_info	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_design_tech_info design_tech_info;$/;"	m	struct:s_spice_model
dir	SRC/include/logic_types.h	/^	enum PORTS dir; \/* port direction *\/$/;"	m	struct:s_model_ports	typeref:enum:s_model_ports::PORTS
directionality	SRC/include/physical_types.h	/^	enum e_directionality directionality;$/;"	m	struct:s_segment_inf	typeref:enum:s_segment_inf::e_directionality
disabled_in_packing	SRC/include/physical_types.h	/^    boolean disabled_in_packing;$/;"	m	struct:s_mode
dptr	SRC/fpga_spice_include/linkedlist.h	/^  void* dptr;$/;"	m	struct:s_llist
driver_pin	SRC/include/physical_types.h	/^	int driver_pin;$/;"	m	struct:s_pb_graph_edge
driver_set	SRC/include/physical_types.h	/^	int driver_set;$/;"	m	struct:s_pb_graph_edge
dump_explicit_port_map	SRC/fpga_spice_include/spice_types.h	/^  boolean dump_explicit_port_map;$/;"	m	struct:s_spice_model
dump_structural_verilog	SRC/fpga_spice_include/spice_types.h	/^  boolean dump_structural_verilog;$/;"	m	struct:s_spice_model
dynamic	SRC/include/physical_types.h	/^	float dynamic;$/;"	m	struct:s_power_usage
e	SRC/include/ezxml.h	/^	char *e; \/* end of work area *\/$/;"	m	struct:ezxml_root
e_Fc_type	SRC/include/physical_types.h	/^enum e_Fc_type {$/;"	g
e_directionality	SRC/include/physical_types.h	/^enum e_directionality {$/;"	g
e_grid_loc_type	SRC/include/physical_types.h	/^enum e_grid_loc_type {$/;"	g
e_interconnect	SRC/include/physical_types.h	/^enum e_interconnect {$/;"	g
e_pb_graph_pin_type	SRC/include/physical_types.h	/^enum e_pb_graph_pin_type {$/;"	g
e_pb_type_class	SRC/include/physical_types.h	/^enum e_pb_type_class {$/;"	g
e_pin_location_distr	SRC/include/physical_types.h	/^enum e_pin_location_distr {$/;"	g
e_pin_to_pin_annotation_format	SRC/include/physical_types.h	/^enum e_pin_to_pin_annotation_format {$/;"	g
e_pin_to_pin_annotation_type	SRC/include/physical_types.h	/^enum e_pin_to_pin_annotation_type {$/;"	g
e_pin_to_pin_capacitance_annotations	SRC/include/physical_types.h	/^enum e_pin_to_pin_capacitance_annotations {$/;"	g
e_pin_to_pin_delay_annotations	SRC/include/physical_types.h	/^enum e_pin_to_pin_delay_annotations {$/;"	g
e_pin_to_pin_mode_select_annotations	SRC/include/physical_types.h	/^enum e_pin_to_pin_mode_select_annotations {$/;"	g
e_pin_to_pin_pack_pattern_annotations	SRC/include/physical_types.h	/^enum e_pin_to_pin_pack_pattern_annotations {$/;"	g
e_pin_type	SRC/include/physical_types.h	/^enum e_pin_type {$/;"	g
e_power_buffer_type	SRC/include/physical_types.h	/^} e_power_buffer_type;$/;"	t	typeref:enum:__anon2
e_power_estimation_method	SRC/include/physical_types.h	/^typedef enum e_power_estimation_method_ e_power_estimation_method;$/;"	t	typeref:enum:e_power_estimation_method_
e_power_estimation_method_	SRC/include/physical_types.h	/^enum e_power_estimation_method_ {$/;"	g
e_power_wire_type	SRC/include/physical_types.h	/^} e_power_wire_type;$/;"	t	typeref:enum:__anon1
e_process_corner	SRC/fpga_spice_include/spice_types.h	/^enum e_process_corner {$/;"	g
e_side	SRC/include/sides.h	/^enum e_side {$/;"	g
e_spice_accuracy_type	SRC/fpga_spice_include/spice_types.h	/^enum e_spice_accuracy_type {$/;"	g
e_spice_ff_trigger_type	SRC/fpga_spice_include/spice_types.h	/^enum e_spice_ff_trigger_type {$/;"	g
e_spice_model_buffer_type	SRC/fpga_spice_include/spice_types.h	/^enum e_spice_model_buffer_type {$/;"	g
e_spice_model_design_tech	SRC/fpga_spice_include/spice_types.h	/^enum e_spice_model_design_tech {$/;"	g
e_spice_model_gate_type	SRC/fpga_spice_include/spice_types.h	/^enum e_spice_model_gate_type {$/;"	g
e_spice_model_pass_gate_logic_type	SRC/fpga_spice_include/spice_types.h	/^enum e_spice_model_pass_gate_logic_type {$/;"	g
e_spice_model_port_type	SRC/fpga_spice_include/spice_types.h	/^enum e_spice_model_port_type {$/;"	g
e_spice_model_structure	SRC/fpga_spice_include/spice_types.h	/^enum e_spice_model_structure {$/;"	g
e_spice_model_type	SRC/fpga_spice_include/spice_types.h	/^enum e_spice_model_type {$/;"	g
e_spice_pb_port_type	SRC/fpga_spice_include/spice_types.h	/^enum e_spice_pb_port_type {$/;"	g
e_spice_pin2pin_interc_type	SRC/fpga_spice_include/spice_types.h	/^enum e_spice_pin2pin_interc_type {$/;"	g
e_spice_tb_type	SRC/fpga_spice_include/spice_types.h	/^enum e_spice_tb_type {$/;"	g
e_spice_tech_lib_type	SRC/fpga_spice_include/spice_types.h	/^enum e_spice_tech_lib_type {$/;"	g
e_spice_trans_type	SRC/fpga_spice_include/spice_types.h	/^enum e_spice_trans_type {$/;"	g
e_sram_orgz	SRC/fpga_spice_include/spice_types.h	/^enum e_sram_orgz {$/;"	g
e_stat	SRC/include/physical_types.h	/^enum e_stat {$/;"	g
e_switch_block_type	SRC/include/physical_types.h	/^enum e_switch_block_type {$/;"	g
e_swseg_pattern_type	SRC/include/physical_types.h	/^enum e_swseg_pattern_type {$/;"	g
e_tech_comp	SRC/include/arch_types_mrfpga.h	/^enum e_tech_comp { $/;"	g
e_wire_model_type	SRC/fpga_spice_include/spice_types.h	/^enum e_wire_model_type {$/;"	g
energy_per_toggle	SRC/include/physical_types.h	/^	float energy_per_toggle;$/;"	m	struct:s_port_power
ent	SRC/include/ezxml.h	/^	char **ent; \/* general entities (ampersand sequences) *\/$/;"	m	struct:ezxml_root
equivalent	SRC/include/physical_types.h	/^	boolean equivalent;$/;"	m	struct:s_port
err	SRC/include/ezxml.h	/^	char err[EZXML_ERRL]; \/* error string *\/$/;"	m	struct:ezxml_root
estimation_method	SRC/include/physical_types.h	/^	e_power_estimation_method estimation_method;$/;"	m	struct:s_pb_type_power
exist	SRC/fpga_spice_include/spice_types.h	/^  int exist;$/;"	m	struct:s_spice_model_buffer
ezxml	SRC/include/ezxml.h	/^struct ezxml {$/;"	s
ezxml_add_child	SRC/ezxml.c	/^ezxml_t ezxml_add_child(ezxml_t xml, char *name, size_t off) {$/;"	f
ezxml_add_child_d	SRC/include/ezxml.h	149;"	d
ezxml_ampencode	SRC/ezxml.c	/^ezxml_ampencode(const char *s, size_t len, char **dst, size_t * dlen,$/;"	f	file:
ezxml_attr	SRC/ezxml.c	/^ezxml_attr(ezxml_t xml, const char *attr) {$/;"	f
ezxml_char_content	SRC/ezxml.c	/^static void ezxml_char_content(ezxml_root_t root, char *s,$/;"	f	file:
ezxml_child	SRC/ezxml.c	/^ezxml_t ezxml_child(ezxml_t xml, const char *name) {$/;"	f
ezxml_close_tag	SRC/ezxml.c	/^static ezxml_t ezxml_close_tag(ezxml_root_t root, char *name, char *s) {$/;"	f	file:
ezxml_cut	SRC/ezxml.c	/^ezxml_t ezxml_cut(ezxml_t xml) {$/;"	f
ezxml_decode	SRC/ezxml.c	/^ezxml_decode(char *s, char **ent, char t) {$/;"	f	file:
ezxml_ent_ok	SRC/ezxml.c	/^static int ezxml_ent_ok(char *name, char *s, char **ent) {$/;"	f	file:
ezxml_err	SRC/ezxml.c	/^static ezxml_t ezxml_err(ezxml_root_t root, char *s, const char *err, ...) {$/;"	f	file:
ezxml_error	SRC/ezxml.c	/^ezxml_error(ezxml_t xml) {$/;"	f
ezxml_free	SRC/ezxml.c	/^void ezxml_free(ezxml_t xml) {$/;"	f
ezxml_free_attr	SRC/ezxml.c	/^static void ezxml_free_attr(char **attr) {$/;"	f	file:
ezxml_get	SRC/ezxml.c	/^ezxml_t ezxml_get(ezxml_t xml, ...) {$/;"	f
ezxml_idx	SRC/ezxml.c	/^ezxml_t ezxml_idx(ezxml_t xml, int idx) {$/;"	f
ezxml_insert	SRC/ezxml.c	/^ezxml_t ezxml_insert(ezxml_t xml, ezxml_t dest, size_t off) {$/;"	f
ezxml_internal_dtd	SRC/ezxml.c	/^static short ezxml_internal_dtd(ezxml_root_t root, char *s,$/;"	f	file:
ezxml_move	SRC/include/ezxml.h	178;"	d
ezxml_name	SRC/include/ezxml.h	108;"	d
ezxml_new	SRC/ezxml.c	/^ezxml_t ezxml_new(char *name) {$/;"	f
ezxml_new_d	SRC/include/ezxml.h	142;"	d
ezxml_next	SRC/include/ezxml.h	101;"	d
ezxml_open_tag	SRC/ezxml.c	/^static void ezxml_open_tag(ezxml_root_t root, int line, char *name, char **attr) {$/;"	f	file:
ezxml_parse_fd	SRC/ezxml.c	/^ezxml_t ezxml_parse_fd(int fd) {$/;"	f
ezxml_parse_file	SRC/ezxml.c	/^ezxml_t ezxml_parse_file(const char *file) {$/;"	f
ezxml_parse_fp	SRC/ezxml.c	/^ezxml_t ezxml_parse_fp(FILE * fp) {$/;"	f
ezxml_parse_str	SRC/ezxml.c	/^ezxml_t ezxml_parse_str(char *s, size_t len) {$/;"	f
ezxml_pi	SRC/ezxml.c	/^ezxml_pi(ezxml_t xml, const char *target) {$/;"	f
ezxml_proc_inst	SRC/ezxml.c	/^static void ezxml_proc_inst(ezxml_root_t root, char *s, size_t len) {$/;"	f	file:
ezxml_remove	SRC/include/ezxml.h	181;"	d
ezxml_root	SRC/include/ezxml.h	/^struct ezxml_root { \/* additional data for the root tag *\/$/;"	s
ezxml_root_t	SRC/include/ezxml.h	/^typedef struct ezxml_root *ezxml_root_t;$/;"	t	typeref:struct:ezxml_root
ezxml_set_attr	SRC/ezxml.c	/^ezxml_t ezxml_set_attr(ezxml_t xml, char *name, char *value) {$/;"	f
ezxml_set_attr_d	SRC/include/ezxml.h	164;"	d
ezxml_set_flag	SRC/ezxml.c	/^ezxml_t ezxml_set_flag(ezxml_t xml, short flag) {$/;"	f
ezxml_set_txt	SRC/ezxml.c	/^ezxml_t ezxml_set_txt(ezxml_t xml, char *txt) {$/;"	f
ezxml_set_txt_d	SRC/include/ezxml.h	156;"	d
ezxml_str2utf8	SRC/ezxml.c	/^ezxml_str2utf8(char **s, size_t * len) {$/;"	f	file:
ezxml_t	SRC/include/ezxml.h	/^typedef struct ezxml *ezxml_t;$/;"	t	typeref:struct:ezxml
ezxml_toxml	SRC/ezxml.c	/^ezxml_toxml(ezxml_t xml) {$/;"	f
ezxml_toxml_r	SRC/ezxml.c	/^ezxml_toxml_r(ezxml_t xml, char **s, size_t * len, size_t * max, size_t start,$/;"	f	file:
ezxml_txt	SRC/include/ezxml.h	111;"	d
ezxml_vget	SRC/ezxml.c	/^ezxml_t ezxml_vget(ezxml_t xml, va_list ap) {$/;"	f
f_per_stage	SRC/fpga_spice_include/spice_types.h	/^  int f_per_stage;$/;"	m	struct:s_spice_model_buffer
fan_in	SRC/include/physical_types.h	/^    int fan_in;$/;"	m	struct:s_interconnect
fan_out	SRC/include/physical_types.h	/^    int fan_out;$/;"	m	struct:s_interconnect
fast	SRC/fpga_spice_include/spice_types.h	/^  int fast;$/;"	m	struct:s_spice_params
file_exists	SRC/util.c	/^boolean file_exists(const char * filename) {$/;"	f
file_line_number	SRC/util.c	/^int file_line_number; \/* file in line number being parsed *\/$/;"	v
findPortByName	SRC/read_xml_arch_file.c	/^static t_port * findPortByName(const char * name, t_pb_type * pb_type,$/;"	f	file:
find_length_llist	SRC/linkedlist.c	/^int find_length_llist(t_llist* head) {$/;"	f
flags	SRC/include/ezxml.h	/^	short flags; \/* additional information *\/$/;"	m	struct:ezxml
format	SRC/include/physical_types.h	/^	enum e_pin_to_pin_annotation_format format;$/;"	m	struct:s_pin_to_pin_annotation	typeref:enum:s_pin_to_pin_annotation::e_pin_to_pin_annotation_format
frac_cb	SRC/include/physical_types.h	/^	float frac_cb;$/;"	m	struct:s_segment_inf
frac_lut	SRC/fpga_spice_include/spice_types.h	/^  boolean frac_lut;$/;"	m	struct:s_spice_model_lut
frac_sb	SRC/include/physical_types.h	/^	float frac_sb;$/;"	m	struct:s_segment_inf
free_chunk_memory	SRC/util.c	/^void free_chunk_memory(t_chunk *chunk_info) {$/;"	f
free_int_list	SRC/util.c	/^void free_int_list(t_linked_int ** int_list_head_ptr) {$/;"	f
free_ivec_matrix	SRC/util.c	/^void free_ivec_matrix(struct s_ivec **ivec_matrix, int nrmin, int nrmax,$/;"	f
free_ivec_matrix3	SRC/util.c	/^void free_ivec_matrix3(struct s_ivec ***ivec_matrix3, int nrmin, int nrmax,$/;"	f
free_ivec_vector	SRC/util.c	/^void free_ivec_vector(struct s_ivec *ivec_vector, int nrmin, int nrmax) {$/;"	f
free_llist	SRC/linkedlist.c	/^void free_llist(t_llist* head) {$/;"	f
free_matrix	SRC/util.c	/^void free_matrix(void *vptr, int nrmin, int nrmax, int ncmin, size_t elsize) {$/;"	f
free_matrix3	SRC/util.c	/^void free_matrix3(void *vptr, int nrmin, int nrmax, int ncmin, int ncmax,$/;"	f
free_matrix4	SRC/util.c	/^void free_matrix4(void *vptr, int nrmin, int nrmax, int ncmin, int ncmax,$/;"	f
freq	SRC/fpga_spice_include/spice_types.h	/^  float freq; $/;"	m	struct:s_spice_net_info
frequency	SRC/include/physical_types.h	/^	int frequency;$/;"	m	struct:s_segment_inf
from_block	SRC/include/cad_types.h	/^	t_pack_pattern_block *from_block;$/;"	m	struct:s_pack_pattern_connections
from_pin	SRC/include/cad_types.h	/^	t_pb_graph_pin *from_pin;$/;"	m	struct:s_pack_pattern_connections
from_pin	SRC/include/physical_types.h	/^	char *from_pin;$/;"	m	struct:s_direct_inf
from_port	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_port* from_port;$/;"	m	struct:s_spice_model_tedge
from_port_pin_number	SRC/fpga_spice_include/spice_types.h	/^  int from_port_pin_number;$/;"	m	struct:s_spice_model_tedge
gate_info	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_gate* gate_info;$/;"	m	struct:s_spice_model_design_tech_info
get_opposite	SRC/sides.cpp	/^enum e_side Side::get_opposite() const {$/;"	f	class:Side
get_rotate_clockwise	SRC/sides.cpp	/^enum e_side Side::get_rotate_clockwise() const {$/;"	f	class:Side
get_rotate_counterclockwise	SRC/sides.cpp	/^enum e_side Side::get_rotate_counterclockwise() const {$/;"	f	class:Side
get_side	SRC/sides.cpp	/^enum e_side Side::get_side() const { $/;"	f	class:Side
grid_conf_bits_lsb	SRC/fpga_spice_include/spice_types.h	/^  int** grid_conf_bits_lsb;$/;"	m	struct:s_sram_orgz_info
grid_conf_bits_msb	SRC/fpga_spice_include/spice_types.h	/^  int** grid_conf_bits_msb;$/;"	m	struct:s_sram_orgz_info
grid_index_high	SRC/fpga_spice_include/spice_types.h	/^  int** grid_index_high;$/;"	m	struct:s_spice_model
grid_index_low	SRC/fpga_spice_include/spice_types.h	/^  int** grid_index_low;$/;"	m	struct:s_spice_model
grid_loc_def	SRC/include/physical_types.h	/^	struct s_grid_loc_def *grid_loc_def; \/* [0..num_def-1] *\/$/;"	m	struct:s_type_descriptor	typeref:struct:s_type_descriptor::s_grid_loc_def
grid_loc_type	SRC/include/physical_types.h	/^	enum e_grid_loc_type grid_loc_type;$/;"	m	struct:s_grid_loc_def	typeref:enum:s_grid_loc_def::e_grid_loc_type
grid_logic_tile_area	SRC/include/physical_types.h	/^	float grid_logic_tile_area;$/;"	m	struct:s_arch
grid_nx	SRC/fpga_spice_include/spice_types.h	/^  int grid_nx; \/* grid size *\/ $/;"	m	struct:s_sram_orgz_info
grid_ny	SRC/fpga_spice_include/spice_types.h	/^  int grid_ny;$/;"	m	struct:s_sram_orgz_info
grid_reserved_conf_bits	SRC/fpga_spice_include/spice_types.h	/^  int** grid_reserved_conf_bits;$/;"	m	struct:s_sram_orgz_info
height	SRC/include/physical_types.h	/^	int height;$/;"	m	struct:s_type_descriptor
idle_mode_name	SRC/include/physical_types.h	/^    char* idle_mode_name;$/;"	m	struct:s_pb_type
in_port_name	SRC/fpga_spice_include/spice_types.h	/^  char* in_port_name;$/;"	m	struct:s_spice_model_delay_info
include_netlist	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_netlist* include_netlist;$/;"	m	struct:s_spice_model
include_netlists	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_netlist* include_netlists; $/;"	m	struct:s_spice
included	SRC/fpga_spice_include/spice_types.h	/^  int included;$/;"	m	struct:s_spice_model_netlist
incremental_cost	SRC/include/cad_types.h	/^	float incremental_cost; \/* cost dependant on current status of packing *\/$/;"	m	struct:s_cluster_placement_primitive
index	SRC/fpga_spice_include/spice_types.h	/^  int index;$/;"	m	struct:s_conf_bit_info
index	SRC/include/cad_types.h	/^	int index; \/* array index  for pattern*\/$/;"	m	struct:s_pack_patterns
index	SRC/include/logic_types.h	/^	int index; \/* indexing for array look-up *\/$/;"	m	struct:s_model_ports
index	SRC/include/logic_types.h	/^	int index;$/;"	m	struct:s_model
index	SRC/include/physical_types.h	/^	int index; \/* index of type descriptor in array (allows for index referencing) *\/$/;"	m	struct:s_type_descriptor
index	SRC/include/physical_types.h	/^	int index;$/;"	m	struct:s_mode
index	SRC/include/physical_types.h	/^	int index;$/;"	m	struct:s_port
index_in_top_tb	SRC/fpga_spice_include/spice_types.h	/^  int index_in_top_tb;$/;"	m	struct:s_conf_bit_info
infer_annotations	SRC/include/physical_types.h	/^	boolean infer_annotations;$/;"	m	struct:s_interconnect
infer_pattern	SRC/include/physical_types.h	/^	boolean infer_pattern; \/*If TRUE, infer pattern based on patterns connected to it*\/$/;"	m	struct:s_pb_graph_edge
init_arch_mrfpga	SRC/read_xml_mrfpga.c	/^void init_arch_mrfpga(t_arch_mrfpga* arch_mrfpga) {$/;"	f
init_buffer_inf	SRC/read_xml_mrfpga.c	/^void init_buffer_inf(t_buffer_inf* buffer_inf) {$/;"	f
init_memristor_inf	SRC/read_xml_mrfpga.c	/^void init_memristor_inf(t_memristor_inf* memristor_inf) {$/;"	f
init_val	SRC/fpga_spice_include/spice_types.h	/^  int init_val;$/;"	m	struct:s_spice_net_info
inport_link_pin	SRC/include/cad_types.h	/^	int inport_link_pin; \/* applicable pin of chain input port *\/$/;"	m	struct:s_model_chain_pattern
input_buffer	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_buffer* input_buffer;$/;"	m	struct:s_spice_model
input_edges	SRC/include/physical_types.h	/^	struct s_pb_graph_edge** input_edges; \/* [0..num_input_edges] *\/$/;"	m	struct:s_pb_graph_pin	typeref:struct:s_pb_graph_pin::s_pb_graph_edge
input_level	SRC/fpga_spice_include/spice_types.h	/^  int* input_level;  \/* [0...num_input] *\/$/;"	m	struct:s_spice_mux_arch
input_link_port	SRC/include/cad_types.h	/^	t_model_ports *input_link_port; \/* pointer to port of chain input *\/$/;"	m	struct:s_model_chain_pattern
input_offset	SRC/fpga_spice_include/spice_types.h	/^  int* input_offset; \/* [0...num_input] *\/ $/;"	m	struct:s_spice_mux_arch
input_pin_class_size	SRC/include/physical_types.h	/^	int *input_pin_class_size; \/* Stores the number of pins that belong to a particular input pin class *\/$/;"	m	struct:s_pb_graph_node
input_pins	SRC/include/physical_types.h	/^	char * input_pins;$/;"	m	struct:s_pin_to_pin_annotation
input_pins	SRC/include/physical_types.h	/^	struct s_pb_graph_pin *** input_pins; \/\/ [0..num_input_ports-1][0..num_pins_per_port-1]$/;"	m	struct:s_interconnect_pins	typeref:struct:s_interconnect_pins::s_pb_graph_pin
input_pins	SRC/include/physical_types.h	/^	t_pb_graph_pin **input_pins; \/* [0..num_input_ports-1] [0..num_port_pins-1]*\/$/;"	m	struct:s_pb_graph_node
input_pins	SRC/include/physical_types.h	/^	t_pb_graph_pin **input_pins;$/;"	m	struct:s_pb_graph_edge
input_ports_eq_auto_detect	SRC/include/physical_types.h	/^    boolean input_ports_eq_auto_detect;$/;"	m	struct:s_type_descriptor
input_slew_fall_time	SRC/fpga_spice_include/spice_types.h	/^  float input_slew_fall_time;  $/;"	m	struct:s_spice_stimulate_params
input_slew_fall_type	SRC/fpga_spice_include/spice_types.h	/^  enum e_spice_accuracy_type input_slew_fall_type;$/;"	m	struct:s_spice_stimulate_params	typeref:enum:s_spice_stimulate_params::e_spice_accuracy_type
input_slew_rise_time	SRC/fpga_spice_include/spice_types.h	/^  float input_slew_rise_time;  $/;"	m	struct:s_spice_stimulate_params
input_slew_rise_type	SRC/fpga_spice_include/spice_types.h	/^  enum e_spice_accuracy_type input_slew_rise_type;$/;"	m	struct:s_spice_stimulate_params	typeref:enum:s_spice_stimulate_params::e_spice_accuracy_type
input_string	SRC/include/physical_types.h	/^	char *input_string;$/;"	m	struct:s_interconnect
input_thres_pct_fall	SRC/fpga_spice_include/spice_types.h	/^  float input_thres_pct_fall;$/;"	m	struct:s_spice_meas_params
input_thres_pct_rise	SRC/fpga_spice_include/spice_types.h	/^  float input_thres_pct_rise;$/;"	m	struct:s_spice_meas_params
inputs	SRC/include/logic_types.h	/^	t_model_ports *inputs; \/* linked list of input\/clock ports *\/$/;"	m	struct:s_model
insert_in_int_list	SRC/util.c	/^insert_in_int_list(t_linked_int * head, int data,$/;"	f
insert_in_vptr_list	SRC/util.c	/^insert_in_vptr_list(struct s_linked_vptr *head, void *vptr_to_add) {$/;"	f
insert_llist_node	SRC/linkedlist.c	/^t_llist* insert_llist_node(t_llist* cur) {$/;"	f
insert_llist_node_before_head	SRC/linkedlist.c	/^t_llist* insert_llist_node_before_head(t_llist* old_head) {$/;"	f
insert_node_to_int_list	SRC/util.c	/^insert_node_to_int_list(struct s_linked_int *head, int int_to_add) {$/;"	f
instances	SRC/include/logic_types.h	/^	void *instances;$/;"	m	struct:s_model
interconnect	SRC/include/physical_types.h	/^	t_interconnect * interconnect;$/;"	m	struct:s_interconnect_pins
interconnect	SRC/include/physical_types.h	/^	t_interconnect * interconnect;$/;"	m	struct:s_pb_graph_edge
interconnect	SRC/include/physical_types.h	/^	t_interconnect *interconnect;$/;"	m	struct:s_mode
interconnect_pins	SRC/include/physical_types.h	/^	t_interconnect_pins ** interconnect_pins; \/* [0..num_modes-1][0..num_interconnect_in_mode] *\/$/;"	m	struct:s_pb_graph_node
interconnect_power	SRC/include/physical_types.h	/^	t_interconnect_power * interconnect_power;$/;"	m	struct:s_interconnect
inv_prefix	SRC/fpga_spice_include/spice_types.h	/^  char* inv_prefix; $/;"	m	struct:s_spice_model_port
inv_spice_model	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model* inv_spice_model;$/;"	m	struct:s_spice_model_port
inv_spice_model_name	SRC/fpga_spice_include/spice_types.h	/^  char* inv_spice_model_name;$/;"	m	struct:s_spice_model_port
io_vdd	SRC/fpga_spice_include/spice_types.h	/^  float io_vdd;$/;"	m	struct:s_spice_tech_lib
ipin_mux_trans_size	SRC/include/physical_types.h	/^	float ipin_mux_trans_size;$/;"	m	struct:s_arch
ipow	SRC/util.c	/^int ipow(int base, int exp) {$/;"	f
is_Fc_frac	SRC/include/physical_types.h	/^	boolean *is_Fc_frac; \/* [0..num_pins-1] *\/$/;"	m	struct:s_type_descriptor
is_Fc_full_flex	SRC/include/physical_types.h	/^	boolean *is_Fc_full_flex; \/* [0..num_pins-1] *\/$/;"	m	struct:s_type_descriptor
is_accurate	SRC/include/arch_types_mrfpga.h	/^  boolean is_accurate;$/;"	m	struct:s_arch_mrfpga
is_block_optional	SRC/include/cad_types.h	/^	boolean *is_block_optional; \/* [0..num_blocks-1] is the block_id in this pattern mandatory or optional to form a molecule *\/$/;"	m	struct:s_pack_patterns
is_chain	SRC/include/cad_types.h	/^	boolean is_chain; \/* Does this pattern chain across logic blocks *\/$/;"	m	struct:s_pack_patterns
is_clock	SRC/include/logic_types.h	/^	boolean is_clock; \/* clock? *\/$/;"	m	struct:s_model_ports
is_clock	SRC/include/physical_types.h	/^	boolean is_clock;$/;"	m	struct:s_port
is_config_enable	SRC/fpga_spice_include/spice_types.h	/^  boolean is_config_enable;$/;"	m	struct:s_spice_model_port
is_default	SRC/fpga_spice_include/spice_types.h	/^  int is_default;$/;"	m	struct:s_spice_model
is_disabled	SRC/include/physical_types.h	/^    boolean is_disabled;$/;"	m	struct:s_pb_graph_edge
is_forced_connection	SRC/include/physical_types.h	/^	boolean is_forced_connection; \/* This output pin connects to one and only one input pin *\/$/;"	m	struct:s_pb_graph_pin
is_global	SRC/fpga_spice_include/spice_types.h	/^  boolean is_global;$/;"	m	struct:s_spice_model_port
is_global_pin	SRC/include/physical_types.h	/^	boolean *is_global_pin; \/* [0..num_pins-1] *\/$/;"	m	struct:s_type_descriptor
is_isolation	SRC/include/arch_types_mrfpga.h	/^  boolean is_isolation;$/;"	m	struct:s_arch_mrfpga
is_junction	SRC/include/arch_types_mrfpga.h	/^  boolean is_junction;$/;"	m	struct:s_arch_mrfpga
is_mrFPGA	SRC/include/arch_types_mrfpga.h	/^  boolean is_mrFPGA;$/;"	m	struct:s_arch_mrfpga
is_non_clock_global	SRC/include/logic_types.h	/^	boolean is_non_clock_global; \/* not a clock but is a special, global, control signal (eg global asynchronous reset, etc) *\/$/;"	m	struct:s_model_ports
is_non_clock_global	SRC/include/physical_types.h	/^	boolean is_non_clock_global;$/;"	m	struct:s_port
is_opin_cblock_defined	SRC/include/arch_types_mrfpga.h	/^  int is_opin_cblock_defined;$/;"	m	struct:s_arch_mrfpga
is_prog	SRC/fpga_spice_include/spice_types.h	/^  boolean is_prog;$/;"	m	struct:s_spice_model_port
is_reset	SRC/fpga_spice_include/spice_types.h	/^  boolean is_reset;$/;"	m	struct:s_spice_model_port
is_set	SRC/fpga_spice_include/spice_types.h	/^  boolean is_set;$/;"	m	struct:s_spice_model_port
is_show_pass_trans	SRC/include/arch_types_mrfpga.h	/^  boolean is_show_pass_trans;$/;"	m	struct:s_arch_mrfpga
is_show_sram	SRC/include/arch_types_mrfpga.h	/^  boolean is_show_sram;$/;"	m	struct:s_arch_mrfpga
is_stack	SRC/include/arch_types_mrfpga.h	/^  boolean is_stack;$/;"	m	struct:s_arch_mrfpga
is_wire_buffer	SRC/include/arch_types_mrfpga.h	/^  boolean is_wire_buffer;$/;"	m	struct:s_arch_mrfpga
leakage	SRC/include/physical_types.h	/^	float leakage;$/;"	m	struct:s_power_usage
leakage_default_mode	SRC/include/physical_types.h	/^	int leakage_default_mode; \/* Default mode for leakage analysis, if block has no set mode *\/$/;"	m	struct:s_pb_type_power
len	SRC/include/ezxml.h	/^	size_t len; \/* length of allocated memory for mmap, -1 for malloc *\/$/;"	m	struct:ezxml_root
length	SRC/include/physical_types.h	/^	int length;$/;"	m	struct:s_segment_inf
level	SRC/fpga_spice_include/spice_types.h	/^  int level;$/;"	m	struct:s_spice_model_wire_param
lib_name	SRC/fpga_spice_include/spice_types.h	/^  char* lib_name; $/;"	m	struct:s_spice_model_port
limit_value	SRC/util.c	/^int limit_value(int cur, int max, const char *name) {$/;"	f
line	SRC/include/ezxml.h	/^	int line;$/;"	m	struct:ezxml
line	SRC/include/physical_types.h	/^	int line;$/;"	m	struct:s_direct_inf
line_num	SRC/include/physical_types.h	/^	int line_num; \/* Interconnect is processed later, need to know what line number it messed up on to give proper error message *\/$/;"	m	struct:s_interconnect
line_num	SRC/include/physical_types.h	/^	int line_num; \/* used to report what line number this annotation is found in architecture file *\/$/;"	m	struct:s_pin_to_pin_annotation
list	SRC/include/util.h	/^	int *list;$/;"	m	struct:s_ivec
list_of_connectable_input_pin_ptrs	SRC/include/physical_types.h	/^	struct s_pb_graph_pin ***list_of_connectable_input_pin_ptrs; \/* [0..depth-1][0..num_connectable_primtive_input_pins-1] what input pins this output can connect to without exiting cluster at given depth *\/$/;"	m	struct:s_pb_graph_pin	typeref:struct:s_pb_graph_pin::s_pb_graph_pin
local_interc_factor	SRC/include/physical_types.h	/^	float local_interc_factor;$/;"	m	struct:s_power_arch
location_map	SRC/fpga_spice_include/spice_types.h	/^  char* location_map;$/;"	m	struct:s_spice_model_buffer
logical_effort_factor	SRC/include/physical_types.h	/^	float logical_effort_factor;$/;"	m	struct:s_power_arch
longline	SRC/include/physical_types.h	/^	boolean longline;$/;"	m	struct:s_segment_inf
loop_breaker_delay_after_max	SRC/include/physical_types.h	/^    char *loop_breaker_delay_after_max;$/;"	m	struct:s_interconnect
loop_breaker_delay_after_max	SRC/include/physical_types.h	/^    char* loop_breaker_delay_after_max;$/;"	m	struct:s_pb_graph_edge
loop_breaker_delay_after_min	SRC/include/physical_types.h	/^    char *loop_breaker_delay_after_min;$/;"	m	struct:s_interconnect
loop_breaker_delay_after_min	SRC/include/physical_types.h	/^    char* loop_breaker_delay_after_min;$/;"	m	struct:s_pb_graph_edge
loop_breaker_delay_before_max	SRC/include/physical_types.h	/^    char *loop_breaker_delay_before_max;$/;"	m	struct:s_interconnect
loop_breaker_delay_before_max	SRC/include/physical_types.h	/^    char* loop_breaker_delay_before_max;$/;"	m	struct:s_pb_graph_edge
loop_breaker_delay_before_min	SRC/include/physical_types.h	/^    char *loop_breaker_delay_before_min;$/;"	m	struct:s_interconnect
loop_breaker_delay_before_min	SRC/include/physical_types.h	/^    char* loop_breaker_delay_before_min;$/;"	m	struct:s_pb_graph_edge
loop_breaker_string	SRC/include/physical_types.h	/^    char *loop_breaker_string;$/;"	m	struct:s_interconnect
lut_frac_level	SRC/fpga_spice_include/spice_types.h	/^  int lut_frac_level;$/;"	m	struct:s_spice_model_port
lut_info	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_lut* lut_info;$/;"	m	struct:s_spice_model_design_tech_info
lut_input_buffer	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_buffer* lut_input_buffer;$/;"	m	struct:s_spice_model
lut_input_inverter	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_buffer* lut_input_inverter;$/;"	m	struct:s_spice_model
lut_intermediate_buffer	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_buffer* lut_intermediate_buffer;$/;"	m	struct:s_spice_model
lut_output_mask	SRC/fpga_spice_include/spice_types.h	/^  int* lut_output_mask;$/;"	m	struct:s_spice_model_port
m	SRC/include/ezxml.h	/^	char *m; \/* original xml string *\/$/;"	m	struct:ezxml_root
main	SRC/ezxml.c	/^main(int argc,$/;"	f
main	SRC/main.c	/^int main(int argc, char **argv) {$/;"	f
main_best_buffer_list	SRC/include/arch_types_mrfpga.h	/^  t_linked_int* main_best_buffer_list;$/;"	m	struct:s_arch_mrfpga
max_internal_delay	SRC/include/physical_types.h	/^	float max_internal_delay;$/;"	m	struct:s_pb_type
max_pins_per_side	SRC/include/arch_types_mrfpga.h	/^  int max_pins_per_side;$/;"	m	struct:s_arch_mrfpga
mc_params	SRC/fpga_spice_include/spice_types.h	/^  t_spice_mc_params mc_params;$/;"	m	struct:s_spice_params
mc_sim	SRC/fpga_spice_include/spice_types.h	/^  boolean mc_sim;$/;"	m	struct:s_spice_mc_params
meas_params	SRC/fpga_spice_include/spice_types.h	/^  t_spice_meas_params meas_params;$/;"	m	struct:s_spice_params
mem_avail	SRC/include/util.h	/^	int mem_avail; \/* number of bytes left in the current chunk *\/$/;"	m	struct:s_chunk
mem_bank_info	SRC/fpga_spice_include/spice_types.h	/^  t_mem_bank_info* mem_bank_info; \/* Only be allocated when orgz type is memory bank *\/$/;"	m	struct:s_sram_orgz_info
mem_model	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model* mem_model; \/* SPICE model of a memory bit *\/$/;"	m	struct:s_mem_bank_info
mem_model	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model* mem_model; \/* SPICE model of a memory bit *\/$/;"	m	struct:s_scff_info
mem_model	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model* mem_model; \/* SPICE model of a memory bit *\/$/;"	m	struct:s_standalone_sram_info
memristor_inf	SRC/include/arch_types_mrfpga.h	/^  t_memristor_inf memristor_inf;$/;"	m	struct:s_arch_mrfpga
messagelogger	SRC/include/util.h	/^typedef unsigned char (*messagelogger)( TIO_MessageMode_t messageMode,$/;"	t
min_size	SRC/include/logic_types.h	/^	int min_size; \/* minimum number of pins *\/$/;"	m	struct:s_model_ports
min_width	SRC/fpga_spice_include/spice_types.h	/^  float min_width;$/;"	m	struct:s_spice_transistor_type
mode_bits	SRC/include/physical_types.h	/^    char* mode_bits; \/* Mode bits to select *\/$/;"	m	struct:s_pb_type
mode_power	SRC/include/physical_types.h	/^	t_mode_power * mode_power;$/;"	m	struct:s_mode
mode_select	SRC/fpga_spice_include/spice_types.h	/^  boolean mode_select;$/;"	m	struct:s_spice_model_port
model	SRC/include/cad_types.h	/^	t_model *model; \/* block associated with chain *\/$/;"	m	struct:s_model_chain_pattern
model	SRC/include/physical_types.h	/^	t_model *model;$/;"	m	struct:s_pb_type
model_library	SRC/include/physical_types.h	/^	t_model *model_library;$/;"	m	struct:s_arch
model_name	SRC/fpga_spice_include/spice_types.h	/^  char* model_name;$/;"	m	struct:s_spice_transistor_type
model_netlist	SRC/fpga_spice_include/spice_types.h	/^  char* model_netlist; \/* SPICE netlist provided by user *\/$/;"	m	struct:s_spice_model
model_port	SRC/include/physical_types.h	/^	t_model_ports *model_port;$/;"	m	struct:s_port
model_ref	SRC/fpga_spice_include/spice_types.h	/^  char* model_ref;$/;"	m	struct:s_spice_tech_lib
models	SRC/include/physical_types.h	/^	t_model *models;$/;"	m	struct:s_arch
modes	SRC/include/physical_types.h	/^	t_mode *modes; \/* [0..num_modes-1] *\/$/;"	m	struct:s_pb_type
mux_info	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_mux* mux_info;$/;"	m	struct:s_spice_model_design_tech_info
mux_num_level	SRC/fpga_spice_include/spice_types.h	/^  int mux_num_level;$/;"	m	struct:s_spice_model_mux
mux_trans_size	SRC/include/physical_types.h	/^	float mux_trans_size;$/;"	m	struct:s_switch_inf
mux_transistor_size	SRC/include/physical_types.h	/^	float mux_transistor_size;$/;"	m	struct:s_power_arch
my_atoi	SRC/util.c	/^int my_atoi(const char *str) {$/;"	f
my_calloc	SRC/util.c	/^my_calloc(size_t nelem, size_t size) {$/;"	f
my_chunk_malloc	SRC/util.c	/^my_chunk_malloc(size_t size, t_chunk *chunk_info) {$/;"	f
my_fgets	SRC/util.c	/^my_fgets(char *buf, int max_size, FILE * fp) {$/;"	f
my_fopen	SRC/util.c	/^my_fopen(const char *fname, const char *flag, int prompt) {$/;"	f
my_frand	SRC/util.c	/^float my_frand(void) {$/;"	f
my_free	SRC/read_xml_spice_util.c	/^void my_free(void* ptr) {$/;"	f
my_irand	SRC/util.c	/^int my_irand(int imax) {$/;"	f
my_malloc	SRC/util.c	/^my_malloc(size_t size) {$/;"	f
my_realloc	SRC/util.c	/^my_realloc(void *ptr, size_t size) {$/;"	f
my_srandom	SRC/util.c	/^void my_srandom(int seed) {$/;"	f
my_strdup	SRC/util.c	/^my_strdup(const char *str) {$/;"	f
my_strncpy	SRC/util.c	/^my_strncpy(char *dest, const char *src, size_t size) {$/;"	f
my_strtok	SRC/util.c	/^my_strtok(char *ptr, const char *tokens, FILE * fp, char *buf) {$/;"	f
name	SRC/fpga_spice_include/spice_types.h	/^  char* name;$/;"	m	struct:s_spice_model
name	SRC/include/cad_types.h	/^	char *name; \/* name of this chain of logic *\/$/;"	m	struct:s_model_chain_pattern
name	SRC/include/cad_types.h	/^	char *name; \/* name of this logic model pattern *\/$/;"	m	struct:s_pack_patterns
name	SRC/include/ezxml.h	/^	char *name; \/* tag name *\/$/;"	m	struct:ezxml
name	SRC/include/logic_types.h	/^	char *name; \/* name of this logic model *\/$/;"	m	struct:s_model
name	SRC/include/logic_types.h	/^	char *name; \/* name of this port *\/$/;"	m	struct:s_model_ports
name	SRC/include/physical_types.h	/^	char *name;$/;"	m	struct:s_direct_inf
name	SRC/include/physical_types.h	/^	char *name;$/;"	m	struct:s_interconnect
name	SRC/include/physical_types.h	/^	char *name;$/;"	m	struct:s_switch_inf
name	SRC/include/physical_types.h	/^	char *name;$/;"	m	struct:s_type_descriptor
name	SRC/include/physical_types.h	/^	char* name;$/;"	m	struct:s_mode
name	SRC/include/physical_types.h	/^	char* name;$/;"	m	struct:s_pb_type
name	SRC/include/physical_types.h	/^	char* name;$/;"	m	struct:s_port
name_mux	SRC/include/physical_types.h	/^    char* name_mux;$/;"	m	struct:s_pb_graph_pin
nb_mux	SRC/include/physical_types.h	/^    int nb_mux;$/;"	m	struct:s_pb_graph_edge
nb_pin	SRC/include/physical_types.h	/^    int nb_pin;$/;"	m	struct:s_pb_graph_edge
nelem	SRC/include/util.h	/^	int nelem;$/;"	m	struct:s_ivec
next	SRC/fpga_spice_include/linkedlist.h	/^  t_llist* next;$/;"	m	struct:s_llist
next	SRC/include/cad_types.h	/^	struct s_model_chain_pattern *next; \/* next chain (linked list) *\/$/;"	m	struct:s_model_chain_pattern	typeref:struct:s_model_chain_pattern::s_model_chain_pattern
next	SRC/include/cad_types.h	/^	struct s_pack_pattern_connections *next;$/;"	m	struct:s_pack_pattern_connections	typeref:struct:s_pack_pattern_connections::s_pack_pattern_connections
next	SRC/include/ezxml.h	/^	ezxml_t next; \/* next tag with same name in this section at this depth *\/$/;"	m	struct:ezxml
next	SRC/include/logic_types.h	/^	struct s_model *next; \/* next model (linked list) *\/$/;"	m	struct:s_model	typeref:struct:s_model::s_model
next	SRC/include/logic_types.h	/^	struct s_model_ports *next; \/* next port *\/$/;"	m	struct:s_model_ports	typeref:struct:s_model_ports::s_model_ports
next	SRC/include/util.h	/^	struct s_linked_int *next;$/;"	m	struct:s_linked_int	typeref:struct:s_linked_int::s_linked_int
next	SRC/include/util.h	/^	struct s_linked_vptr *next;$/;"	m	struct:s_linked_vptr	typeref:struct:s_linked_vptr::s_linked_vptr
next_mem_loc_ptr	SRC/include/util.h	/^	char *next_mem_loc_ptr;\/* pointer to the first available (free) *$/;"	m	struct:s_chunk
next_primitive	SRC/include/cad_types.h	/^	struct s_cluster_placement_primitive *next_primitive;$/;"	m	struct:s_cluster_placement_primitive	typeref:struct:s_cluster_placement_primitive::s_cluster_placement_primitive
nint	SRC/include/util.h	24;"	d
nmos_size	SRC/fpga_spice_include/spice_types.h	/^  float nmos_size;$/;"	m	struct:s_spice_model_pass_gate_logic
nominal_vdd	SRC/fpga_spice_include/spice_types.h	/^  float nominal_vdd;$/;"	m	struct:s_spice_tech_lib
num_annotations	SRC/include/physical_types.h	/^	int num_annotations;$/;"	m	struct:s_interconnect
num_annotations	SRC/include/physical_types.h	/^	int num_annotations;$/;"	m	struct:s_pb_type
num_bl	SRC/fpga_spice_include/spice_types.h	/^  int num_bl; \/* Number of Bit Lines in total *\/$/;"	m	struct:s_mem_bank_info
num_blocks	SRC/include/cad_types.h	/^	int num_blocks; \/* number of blocks in pattern *\/$/;"	m	struct:s_pack_patterns
num_cb_switch	SRC/include/physical_types.h	/^    int num_cb_switch;$/;"	m	struct:s_arch
num_class	SRC/include/physical_types.h	/^	int num_class;$/;"	m	struct:s_type_descriptor
num_clock_pins	SRC/include/physical_types.h	/^	int *num_clock_pins; \/* [0..num_clock_ports - 1] *\/$/;"	m	struct:s_pb_graph_node
num_clock_pins	SRC/include/physical_types.h	/^	int num_clock_pins;$/;"	m	struct:s_pb_type
num_clock_ports	SRC/include/physical_types.h	/^	int num_clock_ports;$/;"	m	struct:s_pb_graph_node
num_clocks	SRC/fpga_spice_include/spice_types.h	/^  int num_clocks;$/;"	m	struct:s_spice_stimulate_params
num_connectable_primtive_input_pins	SRC/include/physical_types.h	/^	int *num_connectable_primtive_input_pins; \/* [0..depth-1] number of input pins that this output pin can reach without exiting cluster at given depth *\/$/;"	m	struct:s_pb_graph_pin
num_data_input	SRC/fpga_spice_include/spice_types.h	/^  int num_data_input; \/* Inputs for multiplexing datapath signals*\/ $/;"	m	struct:s_spice_mux_arch
num_delay_info	SRC/fpga_spice_include/spice_types.h	/^  int num_delay_info;$/;"	m	struct:s_spice_model
num_directs	SRC/include/physical_types.h	/^	int num_directs;$/;"	m	struct:s_arch
num_drivers	SRC/include/physical_types.h	/^	int num_drivers;$/;"	m	struct:s_type_descriptor
num_global_clocks	SRC/include/physical_types.h	/^	int num_global_clocks;$/;"	m	struct:s_clock_arch
num_grid_loc_def	SRC/include/physical_types.h	/^	int num_grid_loc_def;$/;"	m	struct:s_type_descriptor
num_include_netlist	SRC/fpga_spice_include/spice_types.h	/^  int num_include_netlist;$/;"	m	struct:s_spice
num_input	SRC/fpga_spice_include/spice_types.h	/^  int num_input; \/* All Inputs including those connect to constant generator *\/$/;"	m	struct:s_spice_mux_arch
num_input_basis	SRC/fpga_spice_include/spice_types.h	/^  int num_input_basis;$/;"	m	struct:s_spice_mux_arch
num_input_edges	SRC/include/physical_types.h	/^	int num_input_edges;$/;"	m	struct:s_pb_graph_pin
num_input_last_level	SRC/fpga_spice_include/spice_types.h	/^  int num_input_last_level;$/;"	m	struct:s_spice_mux_arch
num_input_per_level	SRC/fpga_spice_include/spice_types.h	/^  int* num_input_per_level; \/* [0...num_level] *\/$/;"	m	struct:s_spice_mux_arch
num_input_pin_class	SRC/include/physical_types.h	/^	int num_input_pin_class; \/* number of pin classes that this input pb_graph_node has *\/$/;"	m	struct:s_pb_graph_node
num_input_pins	SRC/include/physical_types.h	/^	int *num_input_pins; \/* [0..num_input_ports - 1] *\/$/;"	m	struct:s_pb_graph_node
num_input_pins	SRC/include/physical_types.h	/^	int num_input_pins; \/* inputs not including clock pins *\/$/;"	m	struct:s_pb_type
num_input_pins	SRC/include/physical_types.h	/^	int num_input_pins;$/;"	m	struct:s_pb_graph_edge
num_input_ports	SRC/include/physical_types.h	/^	int num_input_ports;$/;"	m	struct:s_interconnect_power
num_input_ports	SRC/include/physical_types.h	/^	int num_input_ports;$/;"	m	struct:s_pb_graph_node
num_interconnect	SRC/include/physical_types.h	/^	int num_interconnect;$/;"	m	struct:s_mode
num_level	SRC/fpga_spice_include/spice_types.h	/^  int num_level;$/;"	m	struct:s_spice_mux_arch
num_mc_points	SRC/fpga_spice_include/spice_types.h	/^  int num_mc_points;$/;"	m	struct:s_spice_mc_params
num_mem_bit	SRC/fpga_spice_include/spice_types.h	/^  int num_mem_bit; \/* Number of memory bits in total *\/$/;"	m	struct:s_mem_bank_info
num_mem_bit	SRC/fpga_spice_include/spice_types.h	/^  int num_mem_bit; \/* Number of memory bits in total *\/$/;"	m	struct:s_scff_info
num_mem_bit	SRC/fpga_spice_include/spice_types.h	/^  int num_mem_bit; \/* Number of memory bits in total *\/$/;"	m	struct:s_standalone_sram_info
num_modes	SRC/include/physical_types.h	/^	int num_modes;$/;"	m	struct:s_pb_type
num_mux	SRC/include/physical_types.h	/^    int num_mux;$/;"	m	struct:s_interconnect
num_normal_switch	SRC/include/arch_types_mrfpga.h	/^  short num_normal_switch;$/;"	m	struct:s_arch_mrfpga
num_output_edges	SRC/include/physical_types.h	/^	int num_output_edges;$/;"	m	struct:s_pb_graph_pin
num_output_pin_class	SRC/include/physical_types.h	/^	int num_output_pin_class; \/* number of output pin classes that this pb_graph_node has *\/$/;"	m	struct:s_pb_graph_node
num_output_pins	SRC/include/physical_types.h	/^	int *num_output_pins; \/* [0..num_output_ports - 1] *\/$/;"	m	struct:s_pb_graph_node
num_output_pins	SRC/include/physical_types.h	/^	int num_output_pins;$/;"	m	struct:s_pb_graph_edge
num_output_pins	SRC/include/physical_types.h	/^	int num_output_pins;$/;"	m	struct:s_pb_type
num_output_ports	SRC/include/physical_types.h	/^	int num_output_ports;$/;"	m	struct:s_interconnect_power
num_output_ports	SRC/include/physical_types.h	/^	int num_output_ports;$/;"	m	struct:s_pb_graph_node
num_pack_patterns	SRC/include/physical_types.h	/^	int num_pack_patterns;$/;"	m	struct:s_pb_graph_edge
num_pb	SRC/include/physical_types.h	/^	int num_pb;$/;"	m	struct:s_pb_type
num_pb_type_children	SRC/include/physical_types.h	/^	int num_pb_type_children;$/;"	m	struct:s_mode
num_pin_loc_assignments	SRC/include/physical_types.h	/^	int **num_pin_loc_assignments; \/* [0..height-1][0..3] *\/$/;"	m	struct:s_type_descriptor
num_pin_timing	SRC/include/physical_types.h	/^	int num_pin_timing; \/* primitive ipin to opin timing *\/$/;"	m	struct:s_pb_graph_pin
num_pins	SRC/include/physical_types.h	/^	int num_pins;$/;"	m	struct:s_class
num_pins	SRC/include/physical_types.h	/^	int num_pins;$/;"	m	struct:s_port
num_pins	SRC/include/physical_types.h	/^	int num_pins;$/;"	m	struct:s_type_descriptor
num_pins_per_port	SRC/include/physical_types.h	/^	int num_pins_per_port;$/;"	m	struct:s_interconnect_power
num_port	SRC/fpga_spice_include/spice_types.h	/^  int num_port;$/;"	m	struct:s_spice_model
num_ports	SRC/include/physical_types.h	/^	int num_ports;$/;"	m	struct:s_pb_type
num_receivers	SRC/include/physical_types.h	/^	int num_receivers;$/;"	m	struct:s_type_descriptor
num_scff	SRC/fpga_spice_include/spice_types.h	/^  int num_scff; \/* Number of Scan-chain flip-flops *\/$/;"	m	struct:s_scff_info
num_segments	SRC/include/physical_types.h	/^	int num_segments;$/;"	m	struct:s_arch
num_sigma	SRC/fpga_spice_include/spice_types.h	/^  int num_sigma;$/;"	m	struct:s_spice_mc_variation_params
num_sim_clock_cycles	SRC/fpga_spice_include/spice_types.h	/^  int num_sim_clock_cycles;$/;"	m	struct:s_spicetb_info
num_spice_model	SRC/fpga_spice_include/spice_types.h	/^  int num_spice_model;$/;"	m	struct:s_spice
num_sram	SRC/fpga_spice_include/spice_types.h	/^  int num_sram; \/* Number of SRAMs in total *\/$/;"	m	struct:s_standalone_sram_info
num_switches	SRC/include/physical_types.h	/^	int num_switches;$/;"	m	struct:s_arch
num_swseg_pattern	SRC/include/physical_types.h	/^    int num_swseg_pattern;$/;"	m	struct:s_arch
num_tedges	SRC/fpga_spice_include/spice_types.h	/^  int* num_tedges; \/* 1-D Array, show number of tedges of each pin *\/$/;"	m	struct:s_spice_model_port
num_transistor_type	SRC/fpga_spice_include/spice_types.h	/^  int num_transistor_type;$/;"	m	struct:s_spice_tech_lib
num_value_prop_pairs	SRC/include/physical_types.h	/^	int num_value_prop_pairs;$/;"	m	struct:s_pin_to_pin_annotation
num_wl	SRC/fpga_spice_include/spice_types.h	/^  int num_wl; \/* Number of Word Lines in total *\/$/;"	m	struct:s_mem_bank_info
off	SRC/include/ezxml.h	/^	size_t off; \/* tag offset from start of parent tag character content *\/$/;"	m	struct:ezxml
op_clock_freq	SRC/fpga_spice_include/spice_types.h	/^  float op_clock_freq; \/* Operation clock frequency*\/$/;"	m	struct:s_spice_stimulate_params
open	SRC/ezxml.c	58;"	d	file:
opin_switch	SRC/include/physical_types.h	/^	short opin_switch;$/;"	m	struct:s_segment_inf
opin_to_cb	SRC/include/physical_types.h	/^    boolean opin_to_cb;$/;"	m	struct:s_type_descriptor
ordered	SRC/include/ezxml.h	/^	ezxml_t ordered; \/* next tag, same section and depth, in original order *\/$/;"	m	struct:ezxml
out_file_prefix	SRC/util.c	/^char *out_file_prefix = NULL;$/;"	v
out_port_name	SRC/fpga_spice_include/spice_types.h	/^  char* out_port_name;$/;"	m	struct:s_spice_model_delay_info
outport_link_pin	SRC/include/cad_types.h	/^	int outport_link_pin; \/* applicable pin of chain output port *\/$/;"	m	struct:s_model_chain_pattern
output_buffer	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_buffer* output_buffer;$/;"	m	struct:s_spice_model
output_edges	SRC/include/physical_types.h	/^	struct s_pb_graph_edge** output_edges; \/* [0..num_output_edges] *\/$/;"	m	struct:s_pb_graph_pin	typeref:struct:s_pb_graph_pin::s_pb_graph_edge
output_link_port	SRC/include/cad_types.h	/^	t_model_ports *output_link_port; \/* pointer to port of chain output *\/$/;"	m	struct:s_model_chain_pattern
output_pin_class_size	SRC/include/physical_types.h	/^	int *output_pin_class_size; \/* Stores the number of pins that belong to a particular output pin class *\/$/;"	m	struct:s_pb_graph_node
output_pins	SRC/include/physical_types.h	/^	char * output_pins;$/;"	m	struct:s_pin_to_pin_annotation
output_pins	SRC/include/physical_types.h	/^	struct s_pb_graph_pin *** output_pins; \/\/ [0..num_output_ports-1][0..num_pins_per_port-1]$/;"	m	struct:s_interconnect_pins	typeref:struct:s_interconnect_pins::s_pb_graph_pin
output_pins	SRC/include/physical_types.h	/^	t_pb_graph_pin **output_pins; \/* [0..num_output_ports-1] [0..num_port_pins-1]*\/$/;"	m	struct:s_pb_graph_node
output_pins	SRC/include/physical_types.h	/^	t_pb_graph_pin **output_pins;$/;"	m	struct:s_pb_graph_edge
output_ports_eq_auto_detect	SRC/include/physical_types.h	/^    boolean output_ports_eq_auto_detect;$/;"	m	struct:s_type_descriptor
output_string	SRC/include/physical_types.h	/^	char *output_string;$/;"	m	struct:s_interconnect
output_thres_pct_fall	SRC/fpga_spice_include/spice_types.h	/^  float output_thres_pct_fall;$/;"	m	struct:s_spice_meas_params
output_thres_pct_rise	SRC/fpga_spice_include/spice_types.h	/^  float output_thres_pct_rise;$/;"	m	struct:s_spice_meas_params
outputs	SRC/include/logic_types.h	/^	t_model_ports *outputs; \/* linked list of output ports *\/$/;"	m	struct:s_model
pack_pattern_indices	SRC/include/physical_types.h	/^	int *pack_pattern_indices; \/*[0..num_pack_patterns(of_edge)-1]*\/$/;"	m	struct:s_pb_graph_edge
pack_pattern_names	SRC/include/physical_types.h	/^	char **pack_pattern_names; \/*[0..num_pack_patterns(of_edge)-1]*\/$/;"	m	struct:s_pb_graph_edge
parent	SRC/include/ezxml.h	/^	ezxml_t parent; \/* parent tag, NULL if current tag is root tag *\/$/;"	m	struct:ezxml
parent_mode	SRC/include/physical_types.h	/^	t_mode * parent_mode;$/;"	m	struct:s_interconnect
parent_mode	SRC/include/physical_types.h	/^	t_mode *parent_mode;$/;"	m	struct:s_pb_type
parent_mode_index	SRC/include/physical_types.h	/^	int parent_mode_index;$/;"	m	struct:s_interconnect
parent_node	SRC/include/physical_types.h	/^	struct s_pb_graph_node *parent_node;$/;"	m	struct:s_pb_graph_pin	typeref:struct:s_pb_graph_pin::s_pb_graph_node
parent_pb_graph_node	SRC/include/physical_types.h	/^	struct s_pb_graph_node *parent_pb_graph_node;$/;"	m	struct:s_pb_graph_node	typeref:struct:s_pb_graph_node::s_pb_graph_node
parent_pb_type	SRC/include/physical_types.h	/^	struct s_pb_type *parent_pb_type;$/;"	m	struct:s_mode	typeref:struct:s_mode::s_pb_type
parent_pb_type	SRC/include/physical_types.h	/^	struct s_pb_type *parent_pb_type;$/;"	m	struct:s_port	typeref:struct:s_port::s_pb_type
parent_pin_class	SRC/include/physical_types.h	/^	int *parent_pin_class; \/* [0..depth-1] the grouping of pins that this particular pin belongs to *\/$/;"	m	struct:s_pb_graph_pin
parent_spice_model	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model* parent_spice_model;$/;"	m	struct:s_conf_bit_info
parent_spice_model_index	SRC/fpga_spice_include/spice_types.h	/^  int parent_spice_model_index;$/;"	m	struct:s_conf_bit_info
pass_gate_info	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_pass_gate_logic* pass_gate_info;$/;"	m	struct:s_spice_model_design_tech_info
pass_gate_logic	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_pass_gate_logic* pass_gate_logic;$/;"	m	struct:s_spice_model
path	SRC/fpga_spice_include/spice_types.h	/^  char* path;$/;"	m	struct:s_spice_model_netlist
path	SRC/fpga_spice_include/spice_types.h	/^  char* path;$/;"	m	struct:s_spice_tech_lib
pattern_index	SRC/include/cad_types.h	/^	int pattern_index; \/* index of pattern that this block is a part of *\/$/;"	m	struct:s_pack_pattern_block
pattern_length	SRC/include/physical_types.h	/^  int pattern_length;$/;"	m	struct:s_swseg_pattern_inf
patterns	SRC/include/physical_types.h	/^  boolean* patterns;$/;"	m	struct:s_swseg_pattern_inf
pb_graph_head	SRC/include/physical_types.h	/^	t_pb_graph_node *pb_graph_head;$/;"	m	struct:s_type_descriptor
pb_graph_node	SRC/include/cad_types.h	/^	t_pb_graph_node *pb_graph_node;$/;"	m	struct:s_cluster_placement_primitive
pb_node_power	SRC/include/physical_types.h	/^	t_pb_graph_node_power * pb_node_power;$/;"	m	struct:s_pb_graph_node
pb_type	SRC/include/cad_types.h	/^	const t_pb_type *pb_type; \/* pb_type that this block is an instance of *\/$/;"	m	struct:s_pack_pattern_block
pb_type	SRC/include/physical_types.h	/^	struct s_pb_type *pb_type;$/;"	m	struct:s_pb_graph_node	typeref:struct:s_pb_graph_node::s_pb_type
pb_type	SRC/include/physical_types.h	/^	struct s_pb_type *pb_type;$/;"	m	struct:s_type_descriptor	typeref:struct:s_type_descriptor::s_pb_type
pb_type_children	SRC/include/physical_types.h	/^	struct s_pb_type *pb_type_children; \/* [0..num_child_pb_types] *\/$/;"	m	struct:s_mode	typeref:struct:s_mode::s_pb_type
pb_type_power	SRC/include/physical_types.h	/^	t_pb_type_power * pb_type_power;$/;"	m	struct:s_pb_type
pb_types	SRC/include/logic_types.h	/^	struct s_linked_vptr *pb_types; \/* Physical block types that implement this model *\/$/;"	m	struct:s_model	typeref:struct:s_model::s_linked_vptr
peak	SRC/include/physical_types.h	/^	float peak;$/;"	m	struct:s_chan
period	SRC/include/physical_types.h	/^	float period; \/* Period of clock *\/$/;"	m	struct:s_clock_network
phy_mode_pin_rotate_offset_acc	SRC/include/physical_types.h	/^    int phy_mode_pin_rotate_offset_acc; \/* The pin number will rotate by an offset unit when mapping to physical modes *\/$/;"	m	struct:s_port
phy_pb_type	SRC/include/physical_types.h	/^	struct s_pb_type* phy_pb_type;$/;"	m	struct:s_pb_type	typeref:struct:s_pb_type::s_pb_type
phy_pb_type_port	SRC/include/physical_types.h	/^    t_port* phy_pb_type_port;$/;"	m	struct:s_port
phy_pb_type_port_lsb	SRC/include/physical_types.h	/^    int phy_pb_type_port_lsb;$/;"	m	struct:s_port
phy_pb_type_port_msb	SRC/include/physical_types.h	/^    int phy_pb_type_port_msb;$/;"	m	struct:s_port
physical_mode_name	SRC/include/physical_types.h	/^    char* physical_mode_name;$/;"	m	struct:s_pb_type
physical_mode_num_conf_bits	SRC/include/physical_types.h	/^    int physical_mode_num_conf_bits;$/;"	m	struct:s_pb_type
physical_mode_num_iopads	SRC/include/physical_types.h	/^    int physical_mode_num_iopads;$/;"	m	struct:s_pb_type
physical_mode_num_reserved_conf_bits	SRC/include/physical_types.h	/^    int physical_mode_num_reserved_conf_bits;$/;"	m	struct:s_pb_type
physical_mode_pin	SRC/include/physical_types.h	/^    char* physical_mode_pin;$/;"	m	struct:s_port
physical_mode_pin_rotate_offset	SRC/include/physical_types.h	/^    int physical_mode_pin_rotate_offset; \/* The pin number will rotate by an offset unit when mapping to physical modes *\/$/;"	m	struct:s_port
physical_pb_graph_node	SRC/include/physical_types.h	/^    t_pb_graph_node* physical_pb_graph_node; \/* physical pb_graph_node *\/$/;"	m	struct:s_pb_graph_node
physical_pb_graph_pin	SRC/include/physical_types.h	/^    t_pb_graph_pin* physical_pb_graph_pin;$/;"	m	struct:s_pb_graph_pin
physical_pb_type_index_factor	SRC/include/physical_types.h	/^    float physical_pb_type_index_factor;$/;"	m	struct:s_pb_type
physical_pb_type_index_offset	SRC/include/physical_types.h	/^    int physical_pb_type_index_offset;$/;"	m	struct:s_pb_type
physical_pb_type_name	SRC/include/physical_types.h	/^    char* physical_pb_type_name;$/;"	m	struct:s_pb_type
pi	SRC/include/ezxml.h	/^	char ***pi; \/* processing instructions *\/$/;"	m	struct:ezxml_root
pin_class	SRC/include/physical_types.h	/^	int *pin_class; \/* [0..num_pins-1] *\/$/;"	m	struct:s_type_descriptor
pin_class	SRC/include/physical_types.h	/^	int pin_class;$/;"	m	struct:s_pb_graph_pin
pin_count_in_cluster	SRC/include/physical_types.h	/^	int pin_count_in_cluster;$/;"	m	struct:s_pb_graph_pin
pin_height	SRC/include/physical_types.h	/^	int *pin_height; \/* [0..num_pins-1] *\/$/;"	m	struct:s_type_descriptor
pin_index_per_side	SRC/include/physical_types.h	/^    int* pin_index_per_side;$/;"	m	struct:s_type_descriptor
pin_loc_assignments	SRC/include/physical_types.h	/^	char ****pin_loc_assignments; \/* [0..height-1][0..3][0..num_tokens-1][0..string_name] *\/$/;"	m	struct:s_type_descriptor
pin_location_distribution	SRC/include/physical_types.h	/^	enum e_pin_location_distr pin_location_distribution;$/;"	m	struct:s_type_descriptor	typeref:enum:s_type_descriptor::e_pin_location_distr
pin_number	SRC/include/physical_types.h	/^	int pin_number;$/;"	m	struct:s_pb_graph_pin
pin_power	SRC/include/physical_types.h	/^	t_pb_graph_pin_power * pin_power;$/;"	m	struct:s_pb_graph_pin
pin_ptc_to_side	SRC/include/physical_types.h	/^    int* pin_ptc_to_side;$/;"	m	struct:s_type_descriptor
pin_timing	SRC/include/physical_types.h	/^	struct s_pb_graph_pin** pin_timing; \/* primitive ipin to opin timing *\/$/;"	m	struct:s_pb_graph_pin	typeref:struct:s_pb_graph_pin::s_pb_graph_pin
pin_timing_del_max	SRC/include/physical_types.h	/^	float *pin_timing_del_max; \/* primitive ipin to opin timing *\/$/;"	m	struct:s_pb_graph_pin
pin_toggle_initialized	SRC/include/physical_types.h	/^	boolean pin_toggle_initialized;$/;"	m	struct:s_port_power
pinlist	SRC/include/physical_types.h	/^	int *pinlist; \/* [0..num_pins - 1] *\/$/;"	m	struct:s_class
pinloc	SRC/include/physical_types.h	/^	int ***pinloc; \/* [0..height-1][0..3][0..num_pins-1] *\/$/;"	m	struct:s_type_descriptor
placement_index	SRC/include/physical_types.h	/^	int placement_index;$/;"	m	struct:s_pb_graph_node
placement_index_in_top_node	SRC/include/physical_types.h	/^	int placement_index_in_top_node; \/* index at the top-level pb_graph node *\/$/;"	m	struct:s_pb_graph_node
pmos_size	SRC/fpga_spice_include/spice_types.h	/^  float pmos_size;$/;"	m	struct:s_spice_model_pass_gate_logic
pn_ratio	SRC/fpga_spice_include/spice_types.h	/^  float pn_ratio;$/;"	m	struct:s_spice_tech_lib
port	SRC/include/physical_types.h	/^	t_port *port;$/;"	m	struct:s_pb_graph_pin
port_class	SRC/include/physical_types.h	/^	char * port_class;$/;"	m	struct:s_port
port_index_by_type	SRC/include/physical_types.h	/^	int port_index_by_type;$/;"	m	struct:s_port
port_info_initialized	SRC/include/physical_types.h	/^	boolean port_info_initialized;$/;"	m	struct:s_interconnect_power
port_power	SRC/include/physical_types.h	/^	t_port_power * port_power;$/;"	m	struct:s_port
ports	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_port* ports;$/;"	m	struct:s_spice_model
ports	SRC/include/physical_types.h	/^	t_port *ports; \/* [0..num_ports] *\/$/;"	m	struct:s_pb_type
post	SRC/fpga_spice_include/spice_types.h	/^  int post;$/;"	m	struct:s_spice_params
power	SRC/include/physical_types.h	/^	t_power_arch * power;$/;"	m	struct:s_arch
power_buffer_size	SRC/include/physical_types.h	/^	float power_buffer_size;$/;"	m	struct:s_switch_inf
power_buffer_type	SRC/include/physical_types.h	/^	e_power_buffer_type power_buffer_type;$/;"	m	struct:s_switch_inf
power_gated	SRC/fpga_spice_include/spice_types.h	/^  boolean power_gated;$/;"	m	struct:s_spice_model_design_tech_info
power_method_inherited	SRC/read_xml_arch_file.c	/^e_power_estimation_method power_method_inherited($/;"	f
power_usage	SRC/include/physical_types.h	/^	t_power_usage power_usage; \/* Power usage of this mode *\/$/;"	m	struct:s_mode_power
power_usage	SRC/include/physical_types.h	/^	t_power_usage power_usage; \/* Total power usage of this pb type *\/$/;"	m	struct:s_pb_type_power
power_usage	SRC/include/physical_types.h	/^	t_power_usage power_usage;$/;"	m	struct:s_interconnect_power
power_usage_bufs_wires	SRC/include/physical_types.h	/^	t_power_usage power_usage_bufs_wires; \/* Power dissipated in local buffers and wire switching (Subset of total power) *\/$/;"	m	struct:s_pb_type_power
prefix	SRC/fpga_spice_include/spice_types.h	/^  char* prefix; $/;"	m	struct:s_spice_model_port
prefix	SRC/fpga_spice_include/spice_types.h	/^  char* prefix; \/* Prefix when it show up in the spice netlist *\/$/;"	m	struct:s_spice_model
print_help	SRC/main.c	/^void print_help() {$/;"	f
print_int_matrix3	SRC/util.c	/^void print_int_matrix3(int ***vptr, int nrmin, int nrmax, int ncmin, int ncmax,$/;"	f
priority	SRC/include/physical_types.h	/^	int priority;$/;"	m	struct:s_grid_loc_def
prob	SRC/include/physical_types.h	/^	float prob; \/* Static probability of net assigned to this clock *\/$/;"	m	struct:s_clock_network
probability	SRC/fpga_spice_include/spice_types.h	/^  float probability;$/;"	m	struct:s_spice_net_info
prog_clock_freq	SRC/fpga_spice_include/spice_types.h	/^  float prog_clock_freq; \/* Programming clock frequency, used during programming phase only *\/$/;"	m	struct:s_spice_stimulate_params
prop	SRC/include/physical_types.h	/^	int * prop; \/* [0..num_value_prop_pairs - 1] *\/$/;"	m	struct:s_pin_to_pin_annotation
pwh	SRC/fpga_spice_include/spice_types.h	/^  float pwh;$/;"	m	struct:s_spice_net_info
pwl	SRC/fpga_spice_include/spice_types.h	/^  float pwl;$/;"	m	struct:s_spice_net_info
read	SRC/ezxml.c	59;"	d	file:
read_xml_spice	SRC/include/physical_types.h	/^    boolean read_xml_spice;$/;"	m	struct:s_arch
relative_length	SRC/include/physical_types.h	/^		float relative_length;$/;"	m	union:s_port_power::__anon3
remove_llist_node	SRC/linkedlist.c	/^void remove_llist_node(t_llist* cur) { $/;"	f
repeat	SRC/include/physical_types.h	/^	int repeat;$/;"	m	struct:s_grid_loc_def
res_val	SRC/fpga_spice_include/spice_types.h	/^  float res_val;$/;"	m	struct:s_spice_model_wire_param
reserved_bl	SRC/fpga_spice_include/spice_types.h	/^  int reserved_bl; \/* Number of reserved BLs shared by overall RRAM circuits *\/$/;"	m	struct:s_mem_bank_info
reserved_wl	SRC/fpga_spice_include/spice_types.h	/^  int reserved_wl; \/* Number of reserved WLs shared by overall RRAM circuits *\/$/;"	m	struct:s_mem_bank_info
reverse_llist	SRC/linkedlist.c	/^t_llist* reverse_llist(t_llist* head) {$/;"	f
reverse_scaled	SRC/include/physical_types.h	/^	boolean reverse_scaled;  \/* Scale by (1-prob) *\/$/;"	m	struct:s_port_power
roff	SRC/fpga_spice_include/spice_types.h	/^  float roff;$/;"	m	struct:s_spice_model_rram
ron	SRC/fpga_spice_include/spice_types.h	/^  float ron;$/;"	m	struct:s_spice_model_rram
root_block	SRC/include/cad_types.h	/^	t_pack_pattern_block *root_block; \/* root block used by this pattern *\/$/;"	m	struct:s_pack_patterns
rotate_clockwise	SRC/sides.cpp	/^void Side::rotate_clockwise() {$/;"	f	class:Side
rotate_counterclockwise	SRC/sides.cpp	/^void Side::rotate_counterclockwise() {$/;"	f	class:Side
rr_node_index_physical_pb	SRC/include/physical_types.h	/^	int rr_node_index_physical_pb; \/* rr_node in the physical pb rr_graph*\/$/;"	m	struct:s_pb_graph_pin
rram_info	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_rram* rram_info;$/;"	m	struct:s_spice_model_design_tech_info
rram_pass_tran_value	SRC/include/arch_types_mrfpga.h	/^  float rram_pass_tran_value;$/;"	m	struct:s_arch_mrfpga
rram_variation	SRC/fpga_spice_include/spice_types.h	/^  t_spice_mc_variation_params rram_variation;$/;"	m	struct:s_spice_mc_params
s	SRC/include/ezxml.h	/^	char *s; \/* start of work area *\/$/;"	m	struct:ezxml_root
s_arch	SRC/include/physical_types.h	/^struct s_arch {$/;"	s
s_arch_mrfpga	SRC/include/arch_types_mrfpga.h	/^struct s_arch_mrfpga {$/;"	s
s_buffer_inf	SRC/include/arch_types_mrfpga.h	/^struct s_buffer_inf { $/;"	s
s_chan	SRC/include/physical_types.h	/^typedef struct s_chan {$/;"	s
s_chan_width_dist	SRC/include/physical_types.h	/^typedef struct s_chan_width_dist {$/;"	s
s_chunk	SRC/include/util.h	/^typedef struct s_chunk {$/;"	s
s_class	SRC/include/physical_types.h	/^struct s_class {$/;"	s
s_clb_grid	SRC/include/physical_types.h	/^struct s_clb_grid {$/;"	s
s_clock_arch	SRC/include/physical_types.h	/^struct s_clock_arch {$/;"	s
s_clock_network	SRC/include/physical_types.h	/^struct s_clock_network {$/;"	s
s_cluster_placement_primitive	SRC/include/cad_types.h	/^typedef struct s_cluster_placement_primitive {$/;"	s
s_conf_bit	SRC/fpga_spice_include/spice_types.h	/^struct s_conf_bit {$/;"	s
s_conf_bit_info	SRC/fpga_spice_include/spice_types.h	/^struct s_conf_bit_info {$/;"	s
s_direct_inf	SRC/include/physical_types.h	/^typedef struct s_direct_inf {$/;"	s
s_grid_loc_def	SRC/include/physical_types.h	/^typedef struct s_grid_loc_def {$/;"	s
s_interconnect	SRC/include/physical_types.h	/^struct s_interconnect {$/;"	s
s_interconnect_pins	SRC/include/physical_types.h	/^struct s_interconnect_pins {$/;"	s
s_interconnect_power	SRC/include/physical_types.h	/^struct s_interconnect_power {$/;"	s
s_ivec	SRC/include/util.h	/^typedef struct s_ivec {$/;"	s
s_linked_int	SRC/include/util.h	/^typedef struct s_linked_int {$/;"	s
s_linked_vptr	SRC/include/util.h	/^typedef struct s_linked_vptr {$/;"	s
s_llist	SRC/fpga_spice_include/linkedlist.h	/^struct s_llist$/;"	s
s_mem_bank_info	SRC/fpga_spice_include/spice_types.h	/^struct s_mem_bank_info {$/;"	s
s_memristor_inf	SRC/include/arch_types_mrfpga.h	/^struct s_memristor_inf { $/;"	s
s_mode	SRC/include/physical_types.h	/^struct s_mode {$/;"	s
s_mode_power	SRC/include/physical_types.h	/^struct s_mode_power {$/;"	s
s_model	SRC/include/logic_types.h	/^typedef struct s_model {$/;"	s
s_model_chain_pattern	SRC/include/cad_types.h	/^typedef struct s_model_chain_pattern {$/;"	s
s_model_ports	SRC/include/logic_types.h	/^typedef struct s_model_ports {$/;"	s
s_pack_pattern_block	SRC/include/cad_types.h	/^typedef struct s_pack_pattern_block {$/;"	s
s_pack_pattern_connections	SRC/include/cad_types.h	/^typedef struct s_pack_pattern_connections {$/;"	s
s_pack_patterns	SRC/include/cad_types.h	/^typedef struct s_pack_patterns {$/;"	s
s_pb_graph_edge	SRC/include/physical_types.h	/^struct s_pb_graph_edge {$/;"	s
s_pb_graph_node	SRC/include/physical_types.h	/^struct s_pb_graph_node {$/;"	s
s_pb_graph_node_power	SRC/include/physical_types.h	/^struct s_pb_graph_node_power {$/;"	s
s_pb_graph_pin	SRC/include/physical_types.h	/^struct s_pb_graph_pin {$/;"	s
s_pb_graph_pin_power	SRC/include/physical_types.h	/^struct s_pb_graph_pin_power {$/;"	s
s_pb_type	SRC/include/physical_types.h	/^struct s_pb_type {$/;"	s
s_pb_type_power	SRC/include/physical_types.h	/^struct s_pb_type_power {$/;"	s
s_pin_to_pin_annotation	SRC/include/physical_types.h	/^struct s_pin_to_pin_annotation {$/;"	s
s_port	SRC/include/physical_types.h	/^struct s_port {$/;"	s
s_port_power	SRC/include/physical_types.h	/^struct s_port_power {$/;"	s
s_power_arch	SRC/include/physical_types.h	/^struct s_power_arch {$/;"	s
s_power_usage	SRC/include/physical_types.h	/^struct s_power_usage {$/;"	s
s_reserved_syntax_char	SRC/fpga_spice_include/spice_types.h	/^struct s_reserved_syntax_char {$/;"	s
s_scff_info	SRC/fpga_spice_include/spice_types.h	/^struct s_scff_info {$/;"	s
s_segment_inf	SRC/include/physical_types.h	/^typedef struct s_segment_inf {$/;"	s
s_spice	SRC/fpga_spice_include/spice_types.h	/^struct s_spice {$/;"	s
s_spice_mc_params	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_mc_params {$/;"	s
s_spice_mc_variation_params	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_mc_variation_params {$/;"	s
s_spice_meas_params	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_meas_params {$/;"	s
s_spice_model	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_model {$/;"	s
s_spice_model_buffer	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_model_buffer {$/;"	s
s_spice_model_delay_info	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_model_delay_info {$/;"	s
s_spice_model_design_tech_info	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_model_design_tech_info {$/;"	s
s_spice_model_gate	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_model_gate {$/;"	s
s_spice_model_lut	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_model_lut {$/;"	s
s_spice_model_mux	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_model_mux {$/;"	s
s_spice_model_netlist	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_model_netlist {$/;"	s
s_spice_model_pass_gate_logic	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_model_pass_gate_logic {$/;"	s
s_spice_model_port	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_model_port {$/;"	s
s_spice_model_rram	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_model_rram {$/;"	s
s_spice_model_tedge	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_model_tedge {$/;"	s
s_spice_model_wire_param	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_model_wire_param {$/;"	s
s_spice_mux_arch	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_mux_arch {$/;"	s
s_spice_mux_model	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_mux_model {$/;"	s
s_spice_net_info	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_net_info {$/;"	s
s_spice_params	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_params {$/;"	s
s_spice_stimulate_params	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_stimulate_params {$/;"	s
s_spice_tech_lib	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_tech_lib {$/;"	s
s_spice_transistor_type	SRC/fpga_spice_include/spice_types.h	/^struct s_spice_transistor_type {$/;"	s
s_spicetb_info	SRC/fpga_spice_include/spice_types.h	/^struct s_spicetb_info {$/;"	s
s_sram_inf	SRC/fpga_spice_include/spice_types.h	/^struct s_sram_inf {$/;"	s
s_sram_inf_orgz	SRC/fpga_spice_include/spice_types.h	/^struct s_sram_inf_orgz {$/;"	s
s_sram_orgz_info	SRC/fpga_spice_include/spice_types.h	/^struct s_sram_orgz_info {$/;"	s
s_standalone_sram_info	SRC/fpga_spice_include/spice_types.h	/^struct s_standalone_sram_info {$/;"	s
s_switch_inf	SRC/include/physical_types.h	/^typedef struct s_switch_inf {$/;"	s
s_swseg_pattern_inf	SRC/include/physical_types.h	/^struct s_swseg_pattern_inf {$/;"	s
s_timing_inf	SRC/include/physical_types.h	/^typedef struct s_timing_inf {$/;"	s
s_type_descriptor	SRC/include/physical_types.h	/^struct s_type_descriptor \/* TODO rename this.  maybe physical type descriptor or complex logic block or physical logic block*\/$/;"	s
sb	SRC/include/physical_types.h	/^	boolean *sb;$/;"	m	struct:s_segment_inf
sb_index_high	SRC/fpga_spice_include/spice_types.h	/^  int** sb_index_high;$/;"	m	struct:s_spice_model
sb_index_low	SRC/fpga_spice_include/spice_types.h	/^  int** sb_index_low;$/;"	m	struct:s_spice_model
sb_len	SRC/include/physical_types.h	/^	int sb_len;$/;"	m	struct:s_segment_inf
scaled_by_pin	SRC/include/physical_types.h	/^	t_pb_graph_pin * scaled_by_pin;$/;"	m	struct:s_pb_graph_pin_power
scaled_by_port	SRC/include/physical_types.h	/^	t_port * scaled_by_port;$/;"	m	struct:s_port_power
scaled_by_port_pin_idx	SRC/include/physical_types.h	/^	int scaled_by_port_pin_idx;$/;"	m	struct:s_port_power
scff_info	SRC/fpga_spice_include/spice_types.h	/^  t_scff_info* scff_info; \/* Only be allocated when orgz type is scan-chain *\/$/;"	m	struct:s_sram_orgz_info
scratch_pad	SRC/include/physical_types.h	/^	int scratch_pad; \/* temporary data structure useful to store traversal info *\/$/;"	m	struct:s_pb_graph_pin
search_in_int_list	SRC/util.c	/^t_linked_int* search_in_int_list(t_linked_int* int_list_head, $/;"	f
search_llist_tail	SRC/linkedlist.c	/^t_llist* search_llist_tail(t_llist* head) {$/;"	f
seg_direction_type	SRC/include/physical_types.h	/^  enum e_directionality seg_direction_type;$/;"	m	struct:s_swseg_pattern_inf	typeref:enum:s_swseg_pattern_inf::e_directionality
seg_length	SRC/include/physical_types.h	/^  int seg_length;$/;"	m	struct:s_swseg_pattern_inf
seg_switch	SRC/include/physical_types.h	/^    short seg_switch;$/;"	m	struct:s_segment_inf
set_opposite	SRC/sides.cpp	/^void Side::set_opposite() { $/;"	f	class:Side
set_side	SRC/sides.cpp	/^void Side::set_side(enum e_side side) { $/;"	f	class:Side
set_side	SRC/sides.cpp	/^void Side::set_side(size_t side) { $/;"	f	class:Side
sibling	SRC/include/ezxml.h	/^	ezxml_t sibling; \/* next tag with different name in same section and depth *\/$/;"	m	struct:ezxml
side_	SRC/include/sides.h	/^    enum e_side side_;  $/;"	m	class:Side	typeref:enum:Side::e_side
sim_clock_freq_slack	SRC/fpga_spice_include/spice_types.h	/^  float sim_clock_freq_slack;$/;"	m	struct:s_spice_stimulate_params
sim_num_clock_cycle	SRC/fpga_spice_include/spice_types.h	/^  int sim_num_clock_cycle; \/* Number of clock cycle in simulation *\/$/;"	m	struct:s_spice_meas_params
sim_temp	SRC/fpga_spice_include/spice_types.h	/^  int sim_temp; \/* Simulation Temperature*\/$/;"	m	struct:s_spice_params
size	SRC/fpga_spice_include/spice_types.h	/^  float size;$/;"	m	struct:s_spice_model_buffer
size	SRC/fpga_spice_include/spice_types.h	/^  int size;$/;"	m	struct:s_spice_model_port
size	SRC/fpga_spice_include/spice_types.h	/^  int size;$/;"	m	struct:s_spice_mux_model
size	SRC/include/logic_types.h	/^	int size; \/* maximum number of pins *\/$/;"	m	struct:s_model_ports
slew_fall	SRC/fpga_spice_include/spice_types.h	/^  float slew_fall;$/;"	m	struct:s_spice_net_info
slew_lower_thres_pct_fall	SRC/fpga_spice_include/spice_types.h	/^  float slew_lower_thres_pct_fall;$/;"	m	struct:s_spice_meas_params
slew_lower_thres_pct_rise	SRC/fpga_spice_include/spice_types.h	/^  float slew_lower_thres_pct_rise;$/;"	m	struct:s_spice_meas_params
slew_rise	SRC/fpga_spice_include/spice_types.h	/^  float slew_rise;$/;"	m	struct:s_spice_net_info
slew_upper_thres_pct_fall	SRC/fpga_spice_include/spice_types.h	/^  float slew_upper_thres_pct_fall;$/;"	m	struct:s_spice_meas_params
slew_upper_thres_pct_rise	SRC/fpga_spice_include/spice_types.h	/^  float slew_upper_thres_pct_rise;$/;"	m	struct:s_spice_meas_params
snprintf	SRC/ezxml.c	57;"	d	file:
spice	SRC/include/physical_types.h	/^    t_spice* spice;$/;"	m	struct:s_arch
spice_model	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model* spice_model; \/\/ Xifan TANG: Spice Support$/;"	m	struct:s_sram_inf_orgz
spice_model	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model* spice_model;$/;"	m	struct:s_spice_model_buffer
spice_model	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model* spice_model;$/;"	m	struct:s_spice_model_pass_gate_logic
spice_model	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model* spice_model;$/;"	m	struct:s_spice_model_port
spice_model	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model* spice_model;$/;"	m	struct:s_spice_mux_model
spice_model	SRC/include/physical_types.h	/^    t_spice_model* spice_model;$/;"	m	struct:s_direct_inf
spice_model	SRC/include/physical_types.h	/^    t_spice_model* spice_model;$/;"	m	struct:s_interconnect
spice_model	SRC/include/physical_types.h	/^    t_spice_model* spice_model;$/;"	m	struct:s_pb_type
spice_model	SRC/include/physical_types.h	/^    t_spice_model* spice_model;$/;"	m	struct:s_segment_inf
spice_model	SRC/include/physical_types.h	/^    t_spice_model* spice_model;$/;"	m	struct:s_switch_inf
spice_model_delay_type	SRC/fpga_spice_include/spice_types.h	/^enum spice_model_delay_type {$/;"	g
spice_model_name	SRC/fpga_spice_include/spice_types.h	/^  char* spice_model_name; \/\/ Xifan TANG: Spice Support$/;"	m	struct:s_sram_inf_orgz
spice_model_name	SRC/fpga_spice_include/spice_types.h	/^  char* spice_model_name;$/;"	m	struct:s_spice_model_buffer
spice_model_name	SRC/fpga_spice_include/spice_types.h	/^  char* spice_model_name;$/;"	m	struct:s_spice_model_pass_gate_logic
spice_model_name	SRC/fpga_spice_include/spice_types.h	/^  char* spice_model_name;$/;"	m	struct:s_spice_model_port
spice_model_name	SRC/include/physical_types.h	/^    char* spice_model_name;$/;"	m	struct:s_direct_inf
spice_model_name	SRC/include/physical_types.h	/^    char* spice_model_name;$/;"	m	struct:s_interconnect
spice_model_name	SRC/include/physical_types.h	/^    char* spice_model_name;$/;"	m	struct:s_pb_type
spice_model_name	SRC/include/physical_types.h	/^    char* spice_model_name;$/;"	m	struct:s_segment_inf
spice_model_name	SRC/include/physical_types.h	/^    char* spice_model_name;$/;"	m	struct:s_switch_inf
spice_model_port	SRC/include/physical_types.h	/^    t_spice_model_port* spice_model_port;$/;"	m	struct:s_port
spice_model_sram_offset	SRC/include/physical_types.h	/^    int spice_model_sram_offset;$/;"	m	struct:s_interconnect
spice_model_sram_offset	SRC/include/physical_types.h	/^    int spice_model_sram_offset;$/;"	m	struct:s_pb_type
spice_models	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model* spice_models;$/;"	m	struct:s_spice
spice_mux_arch	SRC/fpga_spice_include/spice_types.h	/^  t_spice_mux_arch* spice_mux_arch;$/;"	m	struct:s_spice_mux_model
spice_params	SRC/fpga_spice_include/spice_types.h	/^  t_spice_params spice_params;$/;"	m	struct:s_spice
spice_reserved	SRC/fpga_spice_include/spice_types.h	/^  boolean spice_reserved;$/;"	m	struct:s_reserved_syntax_char
spice_sram_inf_orgz	SRC/fpga_spice_include/spice_types.h	/^  t_sram_inf_orgz* spice_sram_inf_orgz;$/;"	m	struct:s_sram_inf
spot_int_in_array	SRC/util.c	/^int spot_int_in_array(int array_len, int* array,$/;"	f
sram_bit	SRC/fpga_spice_include/spice_types.h	/^  t_conf_bit* sram_bit;$/;"	m	struct:s_conf_bit_info
sram_inf	SRC/include/physical_types.h	/^    t_sram_inf sram_inf;$/;"	m	struct:s_arch
standalone	SRC/include/ezxml.h	/^	short standalone; \/* non-zero if <?xml standalone="yes"?> *\/$/;"	m	struct:ezxml_root
standalone_sram_info	SRC/fpga_spice_include/spice_types.h	/^  t_standalone_sram_info* standalone_sram_info; \/* Only be allocated when orgz type is standalone *\/$/;"	m	struct:s_sram_orgz_info
start_col	SRC/include/physical_types.h	/^	int start_col;$/;"	m	struct:s_grid_loc_def
start_seg_switch	SRC/include/arch_types_mrfpga.h	/^  short start_seg_switch;$/;"	m	struct:s_arch_mrfpga
stimulate_params	SRC/fpga_spice_include/spice_types.h	/^  t_spice_stimulate_params stimulate_params;$/;"	m	struct:s_spice_params
structure	SRC/fpga_spice_include/spice_types.h	/^  enum e_spice_model_structure structure;$/;"	m	struct:s_spice_model_mux	typeref:enum:s_spice_model_mux::e_spice_model_structure
structure	SRC/fpga_spice_include/spice_types.h	/^  enum e_spice_model_structure structure;$/;"	m	struct:s_spice_mux_arch	typeref:enum:s_spice_mux_arch::e_spice_model_structure
structure	SRC/include/physical_types.h	/^    enum e_spice_model_structure structure;$/;"	m	struct:s_switch_inf	typeref:enum:s_switch_inf::e_spice_model_structure
switch_num_level	SRC/include/physical_types.h	/^    int switch_num_level;$/;"	m	struct:s_switch_inf
swseg_patterns	SRC/include/physical_types.h	/^    t_swseg_pattern_inf* swseg_patterns;$/;"	m	struct:s_arch
syntax_char	SRC/fpga_spice_include/spice_types.h	/^  char syntax_char;$/;"	m	struct:s_reserved_syntax_char
t_arch	SRC/include/physical_types.h	/^typedef struct s_arch t_arch;$/;"	t	typeref:struct:s_arch
t_arch_mrfpga	SRC/include/arch_types_mrfpga.h	/^typedef struct s_arch_mrfpga t_arch_mrfpga;$/;"	t	typeref:struct:s_arch_mrfpga
t_buffer_inf	SRC/include/arch_types_mrfpga.h	/^typedef struct s_buffer_inf t_buffer_inf;$/;"	t	typeref:struct:s_buffer_inf
t_chan	SRC/include/physical_types.h	/^} t_chan;$/;"	t	typeref:struct:s_chan
t_chan_width_dist	SRC/include/physical_types.h	/^} t_chan_width_dist;$/;"	t	typeref:struct:s_chan_width_dist
t_chunk	SRC/include/util.h	/^} t_chunk;$/;"	t	typeref:struct:s_chunk
t_class	SRC/include/physical_types.h	/^typedef struct s_class t_class;$/;"	t	typeref:struct:s_class
t_clock_arch	SRC/include/physical_types.h	/^typedef struct s_clock_arch t_clock_arch;$/;"	t	typeref:struct:s_clock_arch
t_clock_network	SRC/include/physical_types.h	/^typedef struct s_clock_network t_clock_network;$/;"	t	typeref:struct:s_clock_network
t_cluster_placement_primitive	SRC/include/cad_types.h	/^} t_cluster_placement_primitive;$/;"	t	typeref:struct:s_cluster_placement_primitive
t_conf_bit	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_conf_bit t_conf_bit;$/;"	t	typeref:struct:s_conf_bit
t_conf_bit_info	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_conf_bit_info t_conf_bit_info;$/;"	t	typeref:struct:s_conf_bit_info
t_direct_inf	SRC/include/physical_types.h	/^} t_direct_inf;$/;"	t	typeref:struct:s_direct_inf
t_grid_loc_def	SRC/include/physical_types.h	/^} t_grid_loc_def;$/;"	t	typeref:struct:s_grid_loc_def
t_interconnect	SRC/include/physical_types.h	/^typedef struct s_interconnect t_interconnect;$/;"	t	typeref:struct:s_interconnect
t_interconnect_pins	SRC/include/physical_types.h	/^typedef struct s_interconnect_pins t_interconnect_pins;$/;"	t	typeref:struct:s_interconnect_pins
t_interconnect_power	SRC/include/physical_types.h	/^typedef struct s_interconnect_power t_interconnect_power;$/;"	t	typeref:struct:s_interconnect_power
t_ivec	SRC/include/util.h	/^} t_ivec;$/;"	t	typeref:struct:s_ivec
t_linked_int	SRC/include/util.h	/^} t_linked_int;$/;"	t	typeref:struct:s_linked_int
t_linked_vptr	SRC/include/util.h	/^} t_linked_vptr;$/;"	t	typeref:struct:s_linked_vptr
t_llist	SRC/fpga_spice_include/linkedlist.h	/^typedef struct s_llist t_llist;$/;"	t	typeref:struct:s_llist
t_mem_bank_info	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_mem_bank_info t_mem_bank_info;$/;"	t	typeref:struct:s_mem_bank_info
t_memristor_inf	SRC/include/arch_types_mrfpga.h	/^typedef struct s_memristor_inf t_memristor_inf;$/;"	t	typeref:struct:s_memristor_inf
t_mode	SRC/include/physical_types.h	/^typedef struct s_mode t_mode;$/;"	t	typeref:struct:s_mode
t_mode_power	SRC/include/physical_types.h	/^typedef struct s_mode_power t_mode_power;$/;"	t	typeref:struct:s_mode_power
t_model	SRC/include/logic_types.h	/^} t_model;$/;"	t	typeref:struct:s_model
t_model_chain_pattern	SRC/include/cad_types.h	/^} t_model_chain_pattern;$/;"	t	typeref:struct:s_model_chain_pattern
t_model_ports	SRC/include/logic_types.h	/^} t_model_ports;$/;"	t	typeref:struct:s_model_ports
t_pack_pattern_block	SRC/include/cad_types.h	/^} t_pack_pattern_block;$/;"	t	typeref:struct:s_pack_pattern_block
t_pack_pattern_connections	SRC/include/cad_types.h	/^} t_pack_pattern_connections;$/;"	t	typeref:struct:s_pack_pattern_connections
t_pack_patterns	SRC/include/cad_types.h	/^} t_pack_patterns;$/;"	t	typeref:struct:s_pack_patterns
t_pb_graph_edge	SRC/include/physical_types.h	/^typedef struct s_pb_graph_edge t_pb_graph_edge;$/;"	t	typeref:struct:s_pb_graph_edge
t_pb_graph_node	SRC/include/physical_types.h	/^typedef struct s_pb_graph_node t_pb_graph_node;$/;"	t	typeref:struct:s_pb_graph_node
t_pb_graph_node_power	SRC/include/physical_types.h	/^typedef struct s_pb_graph_node_power t_pb_graph_node_power;$/;"	t	typeref:struct:s_pb_graph_node_power
t_pb_graph_pin	SRC/include/physical_types.h	/^typedef struct s_pb_graph_pin t_pb_graph_pin;$/;"	t	typeref:struct:s_pb_graph_pin
t_pb_graph_pin_power	SRC/include/physical_types.h	/^typedef struct s_pb_graph_pin_power t_pb_graph_pin_power;$/;"	t	typeref:struct:s_pb_graph_pin_power
t_pb_type	SRC/include/physical_types.h	/^typedef struct s_pb_type t_pb_type;$/;"	t	typeref:struct:s_pb_type
t_pb_type_power	SRC/include/physical_types.h	/^typedef struct s_pb_type_power t_pb_type_power;$/;"	t	typeref:struct:s_pb_type_power
t_pin_to_pin_annotation	SRC/include/physical_types.h	/^typedef struct s_pin_to_pin_annotation t_pin_to_pin_annotation;$/;"	t	typeref:struct:s_pin_to_pin_annotation
t_port	SRC/include/physical_types.h	/^typedef struct s_port t_port;$/;"	t	typeref:struct:s_port
t_port_power	SRC/include/physical_types.h	/^typedef struct s_port_power t_port_power;$/;"	t	typeref:struct:s_port_power
t_power_arch	SRC/include/physical_types.h	/^typedef struct s_power_arch t_power_arch;$/;"	t	typeref:struct:s_power_arch
t_power_estimation_method	SRC/include/physical_types.h	/^typedef enum e_power_estimation_method_ t_power_estimation_method;$/;"	t	typeref:enum:e_power_estimation_method_
t_power_usage	SRC/include/physical_types.h	/^typedef struct s_power_usage t_power_usage;$/;"	t	typeref:struct:s_power_usage
t_reserved_syntax_char	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_reserved_syntax_char t_reserved_syntax_char;$/;"	t	typeref:struct:s_reserved_syntax_char
t_scff_info	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_scff_info t_scff_info;$/;"	t	typeref:struct:s_scff_info
t_segment_inf	SRC/include/physical_types.h	/^} t_segment_inf;$/;"	t	typeref:struct:s_segment_inf
t_spice	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice t_spice;$/;"	t	typeref:struct:s_spice
t_spice_mc_params	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_mc_params t_spice_mc_params;$/;"	t	typeref:struct:s_spice_mc_params
t_spice_mc_variation_params	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_mc_variation_params t_spice_mc_variation_params;$/;"	t	typeref:struct:s_spice_mc_variation_params
t_spice_meas_params	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_meas_params t_spice_meas_params;$/;"	t	typeref:struct:s_spice_meas_params
t_spice_model	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_model t_spice_model;$/;"	t	typeref:struct:s_spice_model
t_spice_model_buffer	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_model_buffer t_spice_model_buffer;$/;"	t	typeref:struct:s_spice_model_buffer
t_spice_model_delay_info	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_model_delay_info t_spice_model_delay_info;$/;"	t	typeref:struct:s_spice_model_delay_info
t_spice_model_design_tech_info	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_model_design_tech_info t_spice_model_design_tech_info;$/;"	t	typeref:struct:s_spice_model_design_tech_info
t_spice_model_gate	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_model_gate t_spice_model_gate;$/;"	t	typeref:struct:s_spice_model_gate
t_spice_model_lut	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_model_lut t_spice_model_lut;$/;"	t	typeref:struct:s_spice_model_lut
t_spice_model_mux	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_model_mux t_spice_model_mux;$/;"	t	typeref:struct:s_spice_model_mux
t_spice_model_netlist	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_model_netlist t_spice_model_netlist;$/;"	t	typeref:struct:s_spice_model_netlist
t_spice_model_pass_gate_logic	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_model_pass_gate_logic t_spice_model_pass_gate_logic;$/;"	t	typeref:struct:s_spice_model_pass_gate_logic
t_spice_model_port	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_model_port t_spice_model_port;$/;"	t	typeref:struct:s_spice_model_port
t_spice_model_rram	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_model_rram t_spice_model_rram;$/;"	t	typeref:struct:s_spice_model_rram
t_spice_model_tedge	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_model_tedge t_spice_model_tedge;$/;"	t	typeref:struct:s_spice_model_tedge
t_spice_model_wire_param	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_model_wire_param t_spice_model_wire_param;$/;"	t	typeref:struct:s_spice_model_wire_param
t_spice_mux_arch	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_mux_arch t_spice_mux_arch;$/;"	t	typeref:struct:s_spice_mux_arch
t_spice_mux_model	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_mux_model t_spice_mux_model;$/;"	t	typeref:struct:s_spice_mux_model
t_spice_net_info	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_net_info t_spice_net_info;$/;"	t	typeref:struct:s_spice_net_info
t_spice_params	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_params t_spice_params;$/;"	t	typeref:struct:s_spice_params
t_spice_stimulate_params	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_stimulate_params t_spice_stimulate_params;$/;"	t	typeref:struct:s_spice_stimulate_params
t_spice_tech_lib	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_tech_lib t_spice_tech_lib;$/;"	t	typeref:struct:s_spice_tech_lib
t_spice_transistor_type	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spice_transistor_type t_spice_transistor_type;$/;"	t	typeref:struct:s_spice_transistor_type
t_spicetb_info	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_spicetb_info t_spicetb_info;$/;"	t	typeref:struct:s_spicetb_info
t_sram_inf	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_sram_inf t_sram_inf;$/;"	t	typeref:struct:s_sram_inf
t_sram_inf_orgz	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_sram_inf_orgz t_sram_inf_orgz;$/;"	t	typeref:struct:s_sram_inf_orgz
t_sram_orgz_info	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_sram_orgz_info t_sram_orgz_info;$/;"	t	typeref:struct:s_sram_orgz_info
t_standalone_sram_info	SRC/fpga_spice_include/spice_types.h	/^typedef struct s_standalone_sram_info t_standalone_sram_info;$/;"	t	typeref:struct:s_standalone_sram_info
t_switch_block_type	SRC/include/physical_types.h	/^typedef enum e_switch_block_type t_switch_block_type;$/;"	t	typeref:enum:e_switch_block_type
t_switch_inf	SRC/include/physical_types.h	/^} t_switch_inf;$/;"	t	typeref:struct:s_switch_inf
t_swseg_pattern_inf	SRC/include/physical_types.h	/^typedef struct s_swseg_pattern_inf t_swseg_pattern_inf;$/;"	t	typeref:struct:s_swseg_pattern_inf
t_timing_inf	SRC/include/physical_types.h	/^} t_timing_inf;$/;"	t	typeref:struct:s_timing_inf
t_type_descriptor	SRC/include/physical_types.h	/^typedef struct s_type_descriptor t_type_descriptor;$/;"	t	typeref:struct:s_type_descriptor
t_type_ptr	SRC/include/physical_types.h	/^typedef const struct s_type_descriptor *t_type_ptr;$/;"	t	typeref:struct:s_type_descriptor
tap_buf_level	SRC/fpga_spice_include/spice_types.h	/^  int tap_buf_level;$/;"	m	struct:s_spice_model_buffer
tapered_buf	SRC/fpga_spice_include/spice_types.h	/^  int tapered_buf; \/*Valid only when this is a buffer*\/$/;"	m	struct:s_spice_model_buffer
tb_cnt	SRC/fpga_spice_include/spice_types.h	/^  int tb_cnt;$/;"	m	struct:s_spice_model
tb_name	SRC/fpga_spice_include/spice_types.h	/^  char* tb_name;$/;"	m	struct:s_spicetb_info
tech_comp	SRC/include/arch_types_mrfpga.h	/^  enum e_tech_comp tech_comp;$/;"	m	struct:s_arch_mrfpga	typeref:enum:s_arch_mrfpga::e_tech_comp
tech_lib	SRC/fpga_spice_include/spice_types.h	/^  t_spice_tech_lib tech_lib;$/;"	m	struct:s_spice
tedge	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_tedge*** tedge; \/* 3-D array, considering the each pin in this port, [pin_number][num_edges[iedge]] is an edge pointor *\/$/;"	m	struct:s_spice_model_port
temp_net_num	SRC/include/physical_types.h	/^    int temp_net_num;$/;"	m	struct:s_pb_graph_pin
temp_placement_index	SRC/include/physical_types.h	/^    int temp_placement_index;$/;"	m	struct:s_pb_type
temp_scratch_pad	SRC/include/physical_types.h	/^	void *temp_scratch_pad; \/* temporary data, useful for keeping track of things when traversing data structure *\/$/;"	m	struct:s_pb_graph_node
tfall	SRC/fpga_spice_include/spice_types.h	/^  float tfall; \/* Fall condition: delay *\/$/;"	m	struct:s_spice_model_tedge
tileable	SRC/include/physical_types.h	/^    bool tileable; \/* Xifan TANG: tileable rr_graph support *\/$/;"	m	struct:s_arch
timing_analysis_enabled	SRC/include/physical_types.h	/^	boolean timing_analysis_enabled;$/;"	m	struct:s_timing_inf
to_block	SRC/include/cad_types.h	/^	t_pack_pattern_block *to_block;$/;"	m	struct:s_pack_pattern_connections
to_pin	SRC/include/cad_types.h	/^	t_pb_graph_pin *to_pin;$/;"	m	struct:s_pack_pattern_connections
to_pin	SRC/include/physical_types.h	/^	char *to_pin;$/;"	m	struct:s_direct_inf
to_port	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_port* to_port;$/;"	m	struct:s_spice_model_tedge
to_port_pin_number	SRC/fpga_spice_include/spice_types.h	/^  int to_port_pin_number;$/;"	m	struct:s_spice_model_tedge
to_size_t	SRC/sides.cpp	/^size_t Side::to_size_t() const {$/;"	f	class:Side
to_string	SRC/sides.cpp	/^std::string Side::to_string() const { $/;"	f	class:Side
total_pb_pins	SRC/include/physical_types.h	/^	int total_pb_pins; \/* only valid for top-level *\/$/;"	m	struct:s_pb_graph_node
transistor_cnt	SRC/include/physical_types.h	/^	float transistor_cnt;$/;"	m	struct:s_interconnect_power
transistor_cnt_buffers	SRC/include/physical_types.h	/^	float transistor_cnt_buffers;$/;"	m	struct:s_pb_graph_node_power
transistor_cnt_interc	SRC/include/physical_types.h	/^	float transistor_cnt_interc; \/* Total transistor size of the interconnect in this pb *\/$/;"	m	struct:s_pb_graph_node_power
transistor_cnt_pb_children	SRC/include/physical_types.h	/^	float transistor_cnt_pb_children; \/* Total transistor size of this pb *\/$/;"	m	struct:s_pb_graph_node_power
transistor_type	SRC/fpga_spice_include/spice_types.h	/^  char* transistor_type;$/;"	m	struct:s_spice_tech_lib
transistor_types	SRC/fpga_spice_include/spice_types.h	/^  t_spice_transistor_type* transistor_types;$/;"	m	struct:s_spice_tech_lib
transistors_per_SRAM_bit	SRC/include/physical_types.h	/^	float transistors_per_SRAM_bit;$/;"	m	struct:s_power_arch
tri_state_map	SRC/fpga_spice_include/spice_types.h	/^  char* tri_state_map;$/;"	m	struct:s_spice_model_port
trise	SRC/fpga_spice_include/spice_types.h	/^  float trise; \/* Rise condition: delay *\/$/;"	m	struct:s_spice_model_tedge
tsu_tco	SRC/include/physical_types.h	/^	float tsu_tco; \/* For sequential logic elements, this is the setup time (if input) or clock-to-q time (if output) *\/$/;"	m	struct:s_pb_graph_pin
txt	SRC/include/ezxml.h	/^	char *txt; \/* tag character content, empty string if none *\/$/;"	m	struct:ezxml
type	SRC/fpga_spice_include/spice_types.h	/^  enum e_spice_model_buffer_type type;$/;"	m	struct:s_spice_model_buffer	typeref:enum:s_spice_model_buffer::e_spice_model_buffer_type
type	SRC/fpga_spice_include/spice_types.h	/^  enum e_spice_model_gate_type type;$/;"	m	struct:s_spice_model_gate	typeref:enum:s_spice_model_gate::e_spice_model_gate_type
type	SRC/fpga_spice_include/spice_types.h	/^  enum e_spice_model_pass_gate_logic_type type;$/;"	m	struct:s_spice_model_pass_gate_logic	typeref:enum:s_spice_model_pass_gate_logic::e_spice_model_pass_gate_logic_type
type	SRC/fpga_spice_include/spice_types.h	/^  enum e_spice_model_port_type type;$/;"	m	struct:s_spice_model_port	typeref:enum:s_spice_model_port::e_spice_model_port_type
type	SRC/fpga_spice_include/spice_types.h	/^  enum e_spice_model_type type;$/;"	m	struct:s_spice_model	typeref:enum:s_spice_model::e_spice_model_type
type	SRC/fpga_spice_include/spice_types.h	/^  enum e_spice_tech_lib_type type;$/;"	m	struct:s_spice_tech_lib	typeref:enum:s_spice_tech_lib::e_spice_tech_lib_type
type	SRC/fpga_spice_include/spice_types.h	/^  enum e_spice_trans_type type;$/;"	m	struct:s_spice_transistor_type	typeref:enum:s_spice_transistor_type::e_spice_trans_type
type	SRC/fpga_spice_include/spice_types.h	/^  enum e_sram_orgz type;$/;"	m	struct:s_sram_inf_orgz	typeref:enum:s_sram_inf_orgz::e_sram_orgz
type	SRC/fpga_spice_include/spice_types.h	/^  enum e_sram_orgz type;$/;"	m	struct:s_sram_orgz_info	typeref:enum:s_sram_orgz_info::e_sram_orgz
type	SRC/fpga_spice_include/spice_types.h	/^  enum e_wire_model_type type;$/;"	m	struct:s_spice_model_wire_param	typeref:enum:s_spice_model_wire_param::e_wire_model_type
type	SRC/fpga_spice_include/spice_types.h	/^  enum spice_model_delay_type type;$/;"	m	struct:s_spice_model_delay_info	typeref:enum:s_spice_model_delay_info::spice_model_delay_type
type	SRC/include/physical_types.h	/^	enum PORTS type;$/;"	m	struct:s_port	typeref:enum:s_port::PORTS
type	SRC/include/physical_types.h	/^	enum e_interconnect type;$/;"	m	struct:s_interconnect	typeref:enum:s_interconnect::e_interconnect
type	SRC/include/physical_types.h	/^	enum e_pb_graph_pin_type type; \/* Is a sequential logic element (TRUE), inpad\/outpad (TRUE), or neither (FALSE) *\/$/;"	m	struct:s_pb_graph_pin	typeref:enum:s_pb_graph_pin::e_pb_graph_pin_type
type	SRC/include/physical_types.h	/^	enum e_pin_to_pin_annotation_type type;$/;"	m	struct:s_pin_to_pin_annotation	typeref:enum:s_pin_to_pin_annotation::e_pin_to_pin_annotation_type
type	SRC/include/physical_types.h	/^	enum e_pin_type type;$/;"	m	struct:s_class	typeref:enum:s_class::e_pin_type
type	SRC/include/physical_types.h	/^	enum e_stat type;$/;"	m	struct:s_chan	typeref:enum:s_chan::e_stat
type	SRC/include/physical_types.h	/^    char* type;$/;"	m	struct:s_switch_inf
type	SRC/include/physical_types.h	/^  enum e_swseg_pattern_type type;$/;"	m	struct:s_swseg_pattern_inf	typeref:enum:s_swseg_pattern_inf::e_swseg_pattern_type
u	SRC/include/ezxml.h	/^	char *u; \/* UTF-8 conversion of string if original was UTF-16 *\/$/;"	m	struct:ezxml_root
unbuf_switch	SRC/include/physical_types.h	/^  short unbuf_switch;$/;"	m	struct:s_swseg_pattern_inf
used	SRC/include/logic_types.h	/^	int used;$/;"	m	struct:s_model
val	SRC/fpga_spice_include/spice_types.h	/^  int val; \/* binary value to be writtent: either 0 or 1 *\/$/;"	m	struct:s_conf_bit
valid	SRC/include/cad_types.h	/^	boolean valid;$/;"	m	struct:s_cluster_placement_primitive
validate	SRC/sides.cpp	/^bool Side::validate() const {$/;"	f	class:Side
value	SRC/fpga_spice_include/spice_types.h	/^  char* value; $/;"	m	struct:s_spice_model_delay_info
value	SRC/include/physical_types.h	/^	char ** value; \/* [0..num_value_prop_pairs - 1] *\/$/;"	m	struct:s_pin_to_pin_annotation
variation_on	SRC/fpga_spice_include/spice_types.h	/^  boolean variation_on;$/;"	m	struct:s_spice_mc_variation_params
verilog_netlist	SRC/fpga_spice_include/spice_types.h	/^  char* verilog_netlist; \/* Verilog netlist provided by user *\/$/;"	m	struct:s_spice_model
verilog_reserved	SRC/fpga_spice_include/spice_types.h	/^  boolean verilog_reserved;$/;"	m	struct:s_reserved_syntax_char
verilog_sram_inf_orgz	SRC/fpga_spice_include/spice_types.h	/^  t_sram_inf_orgz* verilog_sram_inf_orgz;$/;"	m	struct:s_sram_inf
vpr_crit_path_delay	SRC/fpga_spice_include/spice_types.h	/^  float vpr_crit_path_delay; \/* Reference operation clock frequency *\/$/;"	m	struct:s_spice_stimulate_params
vpr_printf	SRC/util.c	/^messagelogger vpr_printf = PrintHandlerMessage;$/;"	v
width	SRC/include/physical_types.h	/^	float width;$/;"	m	struct:s_chan
wire	SRC/include/physical_types.h	/^	} wire;$/;"	m	struct:s_port_power	typeref:union:s_port_power::__anon3
wire_buffer_inf	SRC/include/arch_types_mrfpga.h	/^  t_buffer_inf wire_buffer_inf;$/;"	m	struct:s_arch_mrfpga
wire_param	SRC/fpga_spice_include/spice_types.h	/^  t_spice_model_wire_param* wire_param;$/;"	m	struct:s_spice_model
wire_switch	SRC/include/physical_types.h	/^	short wire_switch;$/;"	m	struct:s_segment_inf
wire_type	SRC/include/physical_types.h	/^	e_power_wire_type wire_type;$/;"	m	struct:s_port_power
wire_variation	SRC/fpga_spice_include/spice_types.h	/^  t_spice_mc_variation_params wire_variation;$/;"	m	struct:s_spice_mc_params
wl	SRC/fpga_spice_include/spice_types.h	/^  t_conf_bit* wl;$/;"	m	struct:s_conf_bit_info
wprog_reset_nmos	SRC/fpga_spice_include/spice_types.h	/^  float wprog_reset_nmos;$/;"	m	struct:s_spice_model_rram
wprog_reset_pmos	SRC/fpga_spice_include/spice_types.h	/^  float wprog_reset_pmos;$/;"	m	struct:s_spice_model_rram
wprog_set_nmos	SRC/fpga_spice_include/spice_types.h	/^  float wprog_set_nmos;$/;"	m	struct:s_spice_model_rram
wprog_set_pmos	SRC/fpga_spice_include/spice_types.h	/^  float wprog_set_pmos;$/;"	m	struct:s_spice_model_rram
write	SRC/ezxml.c	60;"	d	file:
x_offset	SRC/include/physical_types.h	/^	int x_offset;$/;"	m	struct:s_direct_inf
xml	SRC/include/ezxml.h	/^	struct ezxml xml; \/* is a super-struct built on top of ezxml struct *\/$/;"	m	struct:ezxml_root	typeref:struct:ezxml_root::ezxml
xpeak	SRC/include/physical_types.h	/^	float xpeak;$/;"	m	struct:s_chan
y_offset	SRC/include/physical_types.h	/^	int y_offset;$/;"	m	struct:s_direct_inf
z_offset	SRC/include/physical_types.h	/^	int z_offset;$/;"	m	struct:s_direct_inf
